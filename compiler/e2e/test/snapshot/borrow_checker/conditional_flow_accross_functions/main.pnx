from core import Copy


public enum Option[T]:
	Some(T)
	None


implements[T] Option[T]:
	public function isSome['a](self: &'a this ) -> bool:
        where:
            T: 'a
	
		match self:
			case Some(_): return true
			case None:    return false
			

	public function asRef['a](self: &'a this) -> Option[&'a T]:
        where:
            T: 'a

		match self:
			case Some(value): return Option::Some(value)
			case None: return Option::None


    public function asMutable['a](
        self: &'a mut this
    ) -> Option[&'a mut T]:
        where:
            T: 'a

        match self:
            case Some(value): return Option::Some(value)
            case None: return Option::None


    public function unwrap(self: this) -> T:
        match self:
            case Some(value): return value
            case None: panic


# fake vector
public struct Vector[T]:
    private _marker: phantom T


implements[T] Vector[T]:
    public function new() -> this:
        panic


    public function push['a](self: &'a mut this, value: T):
        where:
            T: 'a


public struct HashMap[K, V]:
	private test: phantom (K, V)


implements[K, V] HashMap[K, V]:
	public function new() -> this:
		return this {
			test: phantom
		}


	public function insert['a](
		self: &'a mut this, 
		key: K, 
		value: V
	) -> Option[V]:
        where:
            K: 'a
            V: 'a 

		panic


	public function get['a, 'b](
		self: &'a this, 
		key: &'b K
	) -> Option[&'a V]:
        where:
            K: 'a + 'b
            V: 'a

		panic


	public function getOrDefault['a](
		self: &'a mut this, 
		key: K,
		default: V
	) -> &'a V:
        where:
            marker Copy[K]
            K: 'a
            V: 'a

		match self.get(&key):
			case Some(value):
				return value

			case None:
				self.insert(key, default)
				return self.get(&key).unwrap()