public enum Option[T]:
	Some(T)
	None


implements[T] Option[T]:
	public function isSome['a](self: &'a this ) -> bool:
        where:
            T: 'a
	
		match self:
			case Some(_): return true
			case None:    return false
			

	public function asRef['a](self: &'a this) -> Option[&'a T]:
        where:
            T: 'a

		match self:
			case Some(value): return Option::Some(value)
			case None: return Option::None


    public function asMutable['a](
        self: &'a mut this
    ) -> Option[&'a mut T]:
        where:
            T: 'a

        match self:
            case Some(value): return Option::Some(value)
            case None: return Option::None


    public function unwrap(self: this) -> T:
        match self:
            case Some(value): return value
            case None: panic


# fake vector
public struct Vector[T]:
    private _marker: phantom T


implements[T] Vector[T]:
    public function new() -> this:
        panic


    public function push['a](self: &'a mut this, value: T):
        where:
            T: 'a


public struct List[T]:
	public value: T
    
    # NOTE: this will create infinite sized struct in the future (use Box)
	public next: Option[List[T]] 


public function createList[T]() -> List[T]:
	panic
    

public function getRefs['a, T](
	mut list: &'a mut List[T]
) -> Vector[&'a mut T]:
    where:
        T: 'a

	let mut vector = Vector::new()

	loop:
		vector.push(&mut list.value)

		match (&mut list.next):
			case Some(next):
				list = next

			case None: return vector