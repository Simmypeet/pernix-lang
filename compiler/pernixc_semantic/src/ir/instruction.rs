//! Contains the definition of [`Instruction`] and its variants.

use pernixc_syntax::syntax_tree::expression::Block;

use super::{
    address::Address,
    alloca::Alloca,
    value::{register::Register, Value},
    State,
};
use crate::arena::ID;

/// An enumeration containing all the possible sources of an unconditional jump.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum UnconditionalJumpSource {
    /// The jump is generated by an `express` expression.
    Express,

    /// The jump is generated by a `continue` statement.
    Continue,

    /// The jump is generated by a `break` statement.
    Break,

    /// The jump is generated implicitly by the compiler.
    ImplicitlyGenerated,
}

/// Represents a jump to another block unconditionally.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct UnconditionalJump {
    /// The target block of the jump.
    pub target: ID<Block>,
}

/// Represents a jump to another block conditionally.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ConditionalJump<T: State> {
    /// The condition of the jump.
    pub condition: Value<T>,

    /// The block to jump to if the condition is true.
    pub true_target: ID<Block>,

    /// The block to jump to if the condition is false.
    pub false_target: ID<Block>,
}

/// An enumeration containing all kinds of jump instructions.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(missing_docs)]
pub enum Jump<T: State> {
    Unconditional(UnconditionalJump),
    Conditional(ConditionalJump<T>),
}

/// Represents a return instruction.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Return<T: State> {
    /// The value to return.
    pub value: Value<T>,
}

/// Represents an assignment of a register.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RegisterAssignment<T: State> {
    /// The register that is being assigned.
    pub id: ID<Register<T>>,
}

/// An instruction that stores a value to the given memory address.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Store<T: State> {
    /// The address where the value will be stored.
    pub address: Address<T>,

    /// The value to store.
    pub value: Value<T>,
}

/// An instruction that allocates a new `alloca` memory.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AllocaAllocation<T: State> {
    /// The ID of the `alloca` that is being allocated.
    pub id: ID<Alloca<T>>,
}

/// An instructions that packs the unpacked elements of a tuple into a packed
/// element.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TuplePack<T: State> {
    /// The address where the unpacked tuple elements will be stored.
    pub store_address: Address<T>,

    /// The address to the tuple where the unpacked elements are stored.
    pub tuple_address: Address<T>,

    /// The number of elements in the tuple before the packed element.
    ///
    /// This is used for calculating which elements are packed and which are
    /// not.
    pub before_packed_element_count: usize,

    /// The number of elements in the tuple after the packed element.
    ///
    /// This is used for calculating which elements are packed and which are
    /// not.
    pub after_packed_element_count: usize,
}

/// An enumeration containig all the basic instructions.
///
/// The basic instructions are the instructions that have no effect on the
/// control flow of the program -- return instructions and jumps do change the
/// flow of the program, so they are not considered basic.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(missing_docs)]
pub enum Basic<T: State> {
    Store(Store<T>),
    RegisterAssignment(RegisterAssignment<T>),
    AllocaAllocation(AllocaAllocation<T>),
    TuplePack(TuplePack<T>),
}

/// Represents an instruction that will be executed in the IR.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(missing_docs)]
pub enum Instruction<T: State> {
    Jump(Jump<T>),
    Return(Return<T>),
    Basic(Basic<T>),
}
