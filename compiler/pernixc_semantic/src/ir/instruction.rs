//! Contains the definition of [`Instruction`] and its variants.

use pernixc_syntax::syntax_tree::expression::Block;

use super::{
    address::{Address, Memory},
    alloca::Alloca,
    register::Register,
    scope::Scope,
};
use crate::{arena::ID, type_system::model::Model};

/// An enumeration containing all the possible sources of an unconditional jump.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum UnconditionalJumpSource {
    /// The jump is generated by an `express` expression.
    Express,

    /// The jump is generated by a `continue` statement.
    Continue,

    /// The jump is generated by a `break` statement.
    Break,

    /// The jump is generated implicitly by the compiler.
    ImplicitlyGenerated,
}

/// Represents a jump to another block unconditionally.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct UnconditionalJump {
    /// The target block of the jump.
    pub target: ID<Block>,
}

/// Represents a jump to another block conditionally.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ConditionalJump<M: Model> {
    /// The condition of the jump.
    pub condition: ID<Register<M>>,

    /// The block to jump to if the condition is true.
    pub true_target: ID<Block>,

    /// The block to jump to if the condition is false.
    pub false_target: ID<Block>,
}

/// An enumeration containing all kinds of jump instructions.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(missing_docs)]
pub enum Jump<M: Model> {
    Unconditional(UnconditionalJump),
    Conditional(ConditionalJump<M>),
}

/// Represents a return instruction.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Return<M: Model> {
    /// The value to return.
    pub value: ID<Register<M>>,
}

/// Represents an assignment of a register.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RegisterAssignment<M: Model> {
    /// The register that is being assigned.
    pub id: ID<Register<M>>,
}

/// An instruction that initializes a memory location with a value.
///
/// This is instruction is typically translated from a `let` statement in the
/// source code.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Initialize<M: Model> {
    /// The address where the value will be stored.
    pub address: Address<Memory<M>>,

    /// The value to store.
    pub value: ID<Register<M>>,
}

/// An instruction that allocates a new `alloca` memory.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AllocaAllocation<M: Model> {
    /// The ID of the `alloca` that is being allocated.
    pub id: ID<Alloca<M>>,
}

/// An instructions that packs the unpacked elements of a tuple into a packed
/// element.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TuplePack<M: Model> {
    /// The address where the unpacked tuple elements will be stored.
    pub store_address: Address<Memory<M>>,

    /// The address to the tuple where the unpacked elements are stored.
    pub tuple_address: Address<Memory<M>>,

    /// The number of elements in the tuple before the packed element.
    ///
    /// This is used for calculating which elements are packed and which are
    /// not.
    pub before_packed_element_count: usize,

    /// The number of elements in the tuple after the packed element.
    ///
    /// This is used for calculating which elements are packed and which are
    /// not.
    pub after_packed_element_count: usize,
}

/// An instruction that pushes a new scope onto the scope stack.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ScopePush(pub ID<Scope>);

/// An instruction that pops a scope from the scope stack.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ScopePop(pub ID<Scope>);

/// An enumeration containig all the basic instructions.
///
/// The basic instructions are the instructions that have no effect on the
/// control flow of the program -- return instructions and jumps do change the
/// flow of the program, so they are not considered basic.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(missing_docs)]
pub enum Instruction<M: Model> {
    Initialize(Initialize<M>),
    RegisterAssignment(RegisterAssignment<M>),
    AllocaAllocation(AllocaAllocation<M>),
    TuplePack(TuplePack<M>),
    ScopePush(ScopePush),
    ScopePop(ScopePop),
}

/// An enumeration containing all the possible terminators.
///
/// Terminators are instructions that change the control flow of the program.
/// Either they move to another block or they return from the function.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(missing_docs)]
pub enum Terminator<M: Model> {
    Jump(Jump<M>),
    Return(Return<M>),
}
