//! Contains the definition of [`Instruction`] and its variants.

use pernixc_syntax::syntax_tree::expression::Block;

use super::value::{register::Register, Value};
use crate::arena::ID;

/// An enumeration containing all the possible sources of an unconditional jump.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum UnconditionalJumpSource {
    /// The jump is generated by an `express` expression.
    Express,

    /// The jump is generated by a `continue` statement.
    Continue,

    /// The jump is generated by a `break` statement.
    Break,

    /// The jump is generated implicitly by the compiler.
    ImplicitlyGenerated,
}

/// Represents a jump to another block unconditionally.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct UnconditionalJump {
    /// The target block of the jump.
    pub target: ID<Block>,
}

/// Represents a jump to another block conditionally.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ConditionalJump {
    /// The condition of the jump.
    pub condition: Value,

    /// The block to jump to if the condition is true.
    pub true_target: ID<Block>,

    /// The block to jump to if the condition is false.
    pub false_target: ID<Block>,
}

/// An enumeration containing all kinds of jump instructions.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(missing_docs)]
pub enum Jump {
    Unconditional(UnconditionalJump),
    Conditional(ConditionalJump),
}

/// Represents a return instruction.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Return {
    /// The value to return.
    pub value: Value,
}

/// Represents an assignment of a register.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RegisterAssignment {
    /// The register that is being assigned.
    pub assignment: ID<Register>,
}

/// An enumeration containig all the basic instructions.
///
/// The basic instructions are the instructions that have no effect on the
/// control flow of the program -- return instructions and jumps do change the
/// flow of the program, so they are not considered basic.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(missing_docs)]
pub enum Basic {
    RegisterAssignment(RegisterAssignment),
}

/// Represents an instruction that will be executed in the IR.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(missing_docs)]
pub enum Instruction {
    Jump(Jump),
    Return(Return),
    Basic(Basic),
}
