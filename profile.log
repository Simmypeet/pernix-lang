SCRIPT  C:\Users\simmy\AppData\Local\nvim-data\lazy\telescope.nvim\ftplugin\TelescopePrompt.lua
Sourced 18 times
Total time:   0.006795
 Self time:   0.006795

count  total (s)   self (s)
                            -- Don't wrap textwidth things
                            vim.opt_local.formatoptions:remove "t"
                            vim.opt_local.formatoptions:remove "c"
                            
                            -- Don't include `showbreak` when calculating strdisplaywidth
                            vim.opt_local.wrap = false
                            
                            -- There's also no reason to enable textwidth here anyway
                            vim.opt_local.textwidth = 0
                            vim.opt_local.scrollbind = false
                            
                            vim.opt_local.signcolumn = "no"

SCRIPT  C:\Users\simmy\AppData\Local\nvim-data\lazy\telescope.nvim\ftplugin\TelescopeResults.lua
Sourced 18 times
Total time:   0.010649
 Self time:   0.010649

count  total (s)   self (s)
                            -- Don't have scrolloff, it makes things weird.
                            vim.opt_local.scrolloff = 0
                            vim.opt_local.scrollbind = false
                            
                            vim.opt_local.signcolumn = "no"

SCRIPT  C:\Users\simmy\AppData\Local\nvim-data\lazy\rust-tools.nvim\ftplugin\rust.vim
Sourced 2 times
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
    2              0.000100 command RustStartStandaloneServerForBuffer :lua require('rust-tools.standalone').start_standalone_client()
                            
                            " Copied from built-in compiler/{rustc,cargo}.vim
    2              0.000031 setlocal errorformat=
                            			\%f:%l:%c:\ %t%*[^:]:\ %m,
                            			\%f:%l:%c:\ %*\\d:%*\\d\ %t%*[^:]:\ %m,
                            			\%-G%f:%l\ %s,
                            			\%-G%*[\ ]^,
                            			\%-G%*[\ ]^%*[~],
                            			\%-G%*[\ ]...
                            
                            " New errorformat (after nightly 2016/08/10)
    2              0.000018 setlocal errorformat+=
                            			\%-G,
                            			\%-Gerror:\ aborting\ %.%#,
                            			\%-Gerror:\ Could\ not\ compile\ %.%#,
                            			\%Eerror:\ %m,
                            			\%Eerror[E%n]:\ %m,
                            			\%Wwarning:\ %m,
                            			\%Inote:\ %m,
                            			\%C\ %#-->\ %f:%l:%c
                            
    2              0.000029 setlocal errorformat+=
                            			\%-G%\\s%#Downloading%.%#,
                            			\%-G%\\s%#Compiling%.%#,
                            			\%-G%\\s%#Finished%.%#,
                            			\%-G%\\s%#error:\ Could\ not\ compile\ %.%#,
                            			\%-G%\\s%#To\ learn\ more\\,%.%#

SCRIPT  C:\tools\neovim\nvim-win64\share\nvim\runtime\ftplugin\rust.vim
Sourced 2 times
Total time:   0.001129
 Self time:   0.001129

count  total (s)   self (s)
                            " Language:     Rust
                            " Description:  Vim ftplugin for Rust
                            " Maintainer:   Chris Morgan <me@chrismorgan.info>
                            " Maintainer:   Kevin Ballard <kevin@sb.org>
                            " Last Change:  June 08, 2016
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim 
                            
    2              0.000023 if exists("b:did_ftplugin")
                            	finish
    2              0.000002 endif
    2              0.000008 let b:did_ftplugin = 1
                            
    2              0.000015 let s:save_cpo = &cpo
    2              0.000019 set cpo&vim
                            
    2              0.000007 augroup rust.vim
    2              0.000042 autocmd!
                            
                            " Variables {{{1
                            
                            " The rust source code at present seems to typically omit a leader on /*!
                            " comments, so we'll use that as our default, but make it easy to switch.
                            " This does not affect indentation at all (I tested it with and without
                            " leader), merely whether a leader is inserted by default or not.
    2              0.000010 if exists("g:rust_bang_comment_leader") && g:rust_bang_comment_leader != 0
                            	" Why is the `,s0:/*,mb:\ ,ex:*/` there, you ask? I don't understand why,
                            	" but without it, */ gets indented one space even if there were no
                            	" leaders. I'm fairly sure that's a Vim bug.
                            	setlocal comments=s1:/*,mb:*,ex:*/,s0:/*,mb:\ ,ex:*/,:///,://!,://
    2              0.000003 else
    2              0.000011 	setlocal comments=s0:/*!,m:\ ,ex:*/,s1:/*,mb:*,ex:*/,:///,://!,://
    2              0.000002 endif
    2              0.000007 setlocal commentstring=//%s
    2              0.000014 setlocal formatoptions-=t formatoptions+=croqnl
                            " j was only added in 7.3.541, so stop complaints about its nonexistence
    2              0.000007 silent! setlocal formatoptions+=j
                            
                            " smartindent will be overridden by indentexpr if filetype indent is on, but
                            " otherwise it's better than nothing.
    2              0.000015 setlocal smartindent nocindent
                            
    2              0.000009 if !exists("g:rust_recommended_style") || g:rust_recommended_style != 0
    2              0.000022 	setlocal tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    2              0.000007 	setlocal textwidth=99
    2              0.000002 endif
                            
                            " This includeexpr isn't perfect, but it's a good start
    2              0.000007 setlocal includeexpr=substitute(v:fname,'::','/','g')
                            
    2              0.000005 setlocal suffixesadd=.rs
                            
    2              0.000007 if exists("g:ftplugin_rust_source_path")
                                let &l:path=g:ftplugin_rust_source_path . ',' . &l:path
    2              0.000002 endif
                            
    2              0.000006 if exists("g:loaded_delimitMate")
                            	if exists("b:delimitMate_excluded_regions")
                            		let b:rust_original_delimitMate_excluded_regions = b:delimitMate_excluded_regions
                            	endif
                            
                            	let s:delimitMate_extra_excluded_regions = ',rustLifetimeCandidate,rustGenericLifetimeCandidate'
                            
                            	" For this buffer, when delimitMate issues the `User delimitMate_map`
                            	" event in the autocommand system, add the above-defined extra excluded
                            	" regions to delimitMate's state, if they have not already been added.
                            	autocmd User <buffer>
                            		\ if expand('<afile>') ==# 'delimitMate_map' && match(
                            		\     delimitMate#Get("excluded_regions"),
                            		\     s:delimitMate_extra_excluded_regions) == -1
                            		\|  let b:delimitMate_excluded_regions =
                            		\       delimitMate#Get("excluded_regions")
                            		\       . s:delimitMate_extra_excluded_regions
                            		\|endif
                            
                            	" For this buffer, when delimitMate issues the `User delimitMate_unmap`
                            	" event in the autocommand system, delete the above-defined extra excluded
                            	" regions from delimitMate's state (the deletion being idempotent and
                            	" having no effect if the extra excluded regions are not present in the
                            	" targeted part of delimitMate's state).
                            	autocmd User <buffer>
                            		\ if expand('<afile>') ==# 'delimitMate_unmap'
                            		\|  let b:delimitMate_excluded_regions = substitute(
                            		\       delimitMate#Get("excluded_regions"),
                            		\       '\C\V' . s:delimitMate_extra_excluded_regions,
                            		\       '', 'g')
                            		\|endif
    2              0.000002 endif
                            
    2              0.000019 if has("folding") && exists('g:rust_fold') && g:rust_fold != 0
                            	let b:rust_set_foldmethod=1
                            	setlocal foldmethod=syntax
                            	if g:rust_fold == 2
                            		setlocal foldlevel<
                            	else
                            		setlocal foldlevel=99
                            	endif
    2              0.000002 endif
                            
    2              0.000013 if has('conceal') && exists('g:rust_conceal') && g:rust_conceal != 0
                            	let b:rust_set_conceallevel=1
                            	setlocal conceallevel=2
    2              0.000002 endif
                            
                            " Motion Commands {{{1
                            
                            " Bind motion commands to support hanging indents
    2              0.000026 nnoremap <silent> <buffer> [[ :call rust#Jump('n', 'Back')<CR>
    2              0.000020 nnoremap <silent> <buffer> ]] :call rust#Jump('n', 'Forward')<CR>
    2              0.000019 xnoremap <silent> <buffer> [[ :call rust#Jump('v', 'Back')<CR>
    2              0.000071 xnoremap <silent> <buffer> ]] :call rust#Jump('v', 'Forward')<CR>
    2              0.000017 onoremap <silent> <buffer> [[ :call rust#Jump('o', 'Back')<CR>
    2              0.000020 onoremap <silent> <buffer> ]] :call rust#Jump('o', 'Forward')<CR>
                            
                            " Commands {{{1
                            
                            " See |:RustRun| for docs
    2              0.000042 command! -nargs=* -complete=file -bang -buffer RustRun call rust#Run(<bang>0, <q-args>)
                            
                            " See |:RustExpand| for docs
    2              0.000036 command! -nargs=* -complete=customlist,rust#CompleteExpand -bang -buffer RustExpand call rust#Expand(<bang>0, <q-args>)
                            
                            " See |:RustEmitIr| for docs
    2              0.000026 command! -nargs=* -buffer RustEmitIr call rust#Emit("llvm-ir", <q-args>)
                            
                            " See |:RustEmitAsm| for docs
    2              0.000019 command! -nargs=* -buffer RustEmitAsm call rust#Emit("asm", <q-args>)
                            
                            " See |:RustPlay| for docs
    2              0.000054 command! -range=% RustPlay :call rust#Play(<count>, <line1>, <line2>, <f-args>)
                            
                            " See |:RustFmt| for docs
    2              0.000012 command! -buffer RustFmt call rustfmt#Format()
                            
                            " See |:RustFmtRange| for docs
    2              0.000029 command! -range -buffer RustFmtRange call rustfmt#FormatRange(<line1>, <line2>)
                            
                            " Mappings {{{1
                            
                            " Bind ⌘R in MacVim to :RustRun
    2              0.000010 nnoremap <silent> <buffer> <D-r> :RustRun<CR>
                            " Bind ⌘⇧R in MacVim to :RustRun! pre-filled with the last args
    2              0.000056 nnoremap <buffer> <D-R> :RustRun! <C-r>=join(b:rust_last_rustc_args)<CR><C-\>erust#AppendCmdLine(' -- ' . join(b:rust_last_args))<CR>
                            
    2              0.000010 if !exists("b:rust_last_rustc_args") || !exists("b:rust_last_args")
    2              0.000006 	let b:rust_last_rustc_args = []
    2              0.000004 	let b:rust_last_args = []
    2              0.000002 endif
                            
                            " Cleanup {{{1
                            
    2              0.000048 let b:undo_ftplugin = "
                            		\ setlocal formatoptions< comments< commentstring< includeexpr< suffixesadd<
                            		\|setlocal tabstop< shiftwidth< softtabstop< expandtab< textwidth<
                            		\|if exists('b:rust_original_delimitMate_excluded_regions')
                            		  \|let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions
                            		  \|unlet b:rust_original_delimitMate_excluded_regions
                            		\|else
                            		  \|unlet! b:delimitMate_excluded_regions
                            		\|endif
                            		\|if exists('b:rust_set_foldmethod')
                            		  \|setlocal foldmethod< foldlevel<
                            		  \|unlet b:rust_set_foldmethod
                            		\|endif
                            		\|if exists('b:rust_set_conceallevel')
                            		  \|setlocal conceallevel<
                            		  \|unlet b:rust_set_conceallevel
                            		\|endif
                            		\|unlet! b:rust_last_rustc_args b:rust_last_args
                            		\|delcommand RustRun
                            		\|delcommand RustExpand
                            		\|delcommand RustEmitIr
                            		\|delcommand RustEmitAsm
                            		\|delcommand RustPlay
                            		\|nunmap <buffer> <D-r>
                            		\|nunmap <buffer> <D-R>
                            		\|nunmap <buffer> [[
                            		\|nunmap <buffer> ]]
                            		\|xunmap <buffer> [[
                            		\|xunmap <buffer> ]]
                            		\|ounmap <buffer> [[
                            		\|ounmap <buffer> ]]
                            		\|set matchpairs-=<:>
                            		\"
                            
                            " }}}1
                            
                            " Code formatting on save
    2              0.000008 if get(g:, "rustfmt_autosave", 0)
                            	autocmd BufWritePre *.rs silent! call rustfmt#Format()
    2              0.000002 endif
                            
    2              0.000003 augroup END
                            
    2              0.000016 let &cpo = s:save_cpo
    2              0.000005 unlet s:save_cpo
                            
                            " vim: set noet sw=8 ts=8:

SCRIPT  C:\tools\neovim\nvim-win64\share\nvim\runtime\indent\rust.vim
Sourced 2 times
Total time:   0.000264
 Self time:   0.000264

count  total (s)   self (s)
                            " Vim indent file
                            " Language:         Rust
                            " Author:           Chris Morgan <me@chrismorgan.info>
                            " Last Change:      2017 Jun 13
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
                            " Only load this indent file when no other was loaded.
    2              0.000012 if exists("b:did_indent")
                            	finish
    2              0.000002 endif
    2              0.000006 let b:did_indent = 1
                            
    2              0.000013 setlocal cindent
    2              0.000012 setlocal cinoptions=L0,(0,Ws,J1,j1
    2              0.000067 setlocal cinkeys=0{,0},!^F,o,O,0[,0]
                            " Don't think cinwords will actually do anything at all... never mind
    2              0.000008 setlocal cinwords=for,if,else,while,loop,impl,mod,unsafe,trait,struct,enum,fn,extern
                            
                            " Some preliminary settings
    2              0.000024 setlocal nolisp		" Make sure lisp indenting doesn't supersede us
    2              0.000006 setlocal autoindent	" indentexpr isn't much help otherwise
                            " Also do indentkeys, otherwise # gets shoved to column 0 :-/
    2              0.000007 setlocal indentkeys=0{,0},!^F,o,O,0[,0]
                            
    2              0.000006 setlocal indentexpr=GetRustIndent(v:lnum)
                            
                            " Only define the function once.
    2              0.000008 if exists("*GetRustIndent")
    2              0.000003 	finish
                            endif
                            
                            let s:save_cpo = &cpo
                            set cpo&vim
                            
                            " Come here when loading the script the first time.
                            
                            function! s:get_line_trimmed(lnum)
                            	" Get the line and remove a trailing comment.
                            	" Use syntax highlighting attributes when possible.
                            	" NOTE: this is not accurate; /* */ or a line continuation could trick it
                            	let line = getline(a:lnum)
                            	let line_len = strlen(line)
                            	if has('syntax_items')
                            		" If the last character in the line is a comment, do a binary search for
                            		" the start of the comment.  synID() is slow, a linear search would take
                            		" too long on a long line.
                            		if synIDattr(synID(a:lnum, line_len, 1), "name") =~ 'Comment\|Todo'
                            			let min = 1
                            			let max = line_len
                            			while min < max
                            				let col = (min + max) / 2
                            				if synIDattr(synID(a:lnum, col, 1), "name") =~ 'Comment\|Todo'
                            					let max = col
                            				else
                            					let min = col + 1
                            				endif
                            			endwhile
                            			let line = strpart(line, 0, min - 1)
                            		endif
                            		return substitute(line, "\s*$", "", "")
                            	else
                            		" Sorry, this is not complete, nor fully correct (e.g. string "//").
                            		" Such is life.
                            		return substitute(line, "\s*//.*$", "", "")
                            	endif
                            endfunction
                            
                            function! s:is_string_comment(lnum, col)
                            	if has('syntax_items')
                            		for id in synstack(a:lnum, a:col)
                            			let synname = synIDattr(id, "name")
                            			if synname == "rustString" || synname =~ "^rustComment"
                            				return 1
                            			endif
                            		endfor
                            	else
                            		" without syntax, let's not even try
                            		return 0
                            	endif
                            endfunction
                            
                            function GetRustIndent(lnum)
                            
                            	" Starting assumption: cindent (called at the end) will do it right
                            	" normally. We just want to fix up a few cases.
                            
                            	let line = getline(a:lnum)
                            
                            	if has('syntax_items')
                            		let synname = synIDattr(synID(a:lnum, 1, 1), "name")
                            		if synname == "rustString"
                            			" If the start of the line is in a string, don't change the indent
                            			return -1
                            		elseif synname =~ '\(Comment\|Todo\)'
                            					\ && line !~ '^\s*/\*'  " not /* opening line
                            			if synname =~ "CommentML" " multi-line
                            				if line !~ '^\s*\*' && getline(a:lnum - 1) =~ '^\s*/\*'
                            					" This is (hopefully) the line after a /*, and it has no
                            					" leader, so the correct indentation is that of the
                            					" previous line.
                            					return GetRustIndent(a:lnum - 1)
                            				endif
                            			endif
                            			" If it's in a comment, let cindent take care of it now. This is
                            			" for cases like "/*" where the next line should start " * ", not
                            			" "* " as the code below would otherwise cause for module scope
                            			" Fun fact: "  /*\n*\n*/" takes two calls to get right!
                            			return cindent(a:lnum)
                            		endif
                            	endif
                            
                            	" cindent gets second and subsequent match patterns/struct members wrong,
                            	" as it treats the comma as indicating an unfinished statement::
                            	"
                            	" match a {
                            	"     b => c,
                            	"         d => e,
                            	"         f => g,
                            	" };
                            
                            	" Search backwards for the previous non-empty line.
                            	let prevlinenum = prevnonblank(a:lnum - 1)
                            	let prevline = s:get_line_trimmed(prevlinenum)
                            	while prevlinenum > 1 && prevline !~ '[^[:blank:]]'
                            		let prevlinenum = prevnonblank(prevlinenum - 1)
                            		let prevline = s:get_line_trimmed(prevlinenum)
                            	endwhile
                            
                            	" Handle where clauses nicely: subsequent values should line up nicely.
                            	if prevline[len(prevline) - 1] == ","
                            				\ && prevline =~# '^\s*where\s'
                            		return indent(prevlinenum) + 6
                            	endif
                            
                            	if prevline[len(prevline) - 1] == ","
                            				\ && s:get_line_trimmed(a:lnum) !~ '^\s*[\[\]{}]'
                            				\ && prevline !~ '^\s*fn\s'
                            				\ && prevline !~ '([^()]\+,$'
                            				\ && s:get_line_trimmed(a:lnum) !~ '^\s*\S\+\s*=>'
                            		" Oh ho! The previous line ended in a comma! I bet cindent will try to
                            		" take this too far... For now, let's normally use the previous line's
                            		" indent.
                            
                            		" One case where this doesn't work out is where *this* line contains
                            		" square or curly brackets; then we normally *do* want to be indenting
                            		" further.
                            		"
                            		" Another case where we don't want to is one like a function
                            		" definition with arguments spread over multiple lines:
                            		"
                            		" fn foo(baz: Baz,
                            		"        baz: Baz) // <-- cindent gets this right by itself
                            		"
                            		" Another case is similar to the previous, except calling a function
                            		" instead of defining it, or any conditional expression that leaves
                            		" an open paren:
                            		"
                            		" foo(baz,
                            		"     baz);
                            		"
                            		" if baz && (foo ||
                            		"            bar) {
                            		"
                            		" Another case is when the current line is a new match arm.
                            		"
                            		" There are probably other cases where we don't want to do this as
                            		" well. Add them as needed.
                            		return indent(prevlinenum)
                            	endif
                            
                            	if !has("patch-7.4.355")
                            		" cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
                            		"
                            		" static FOO : &'static [bool] = [
                            		" true,
                            		"	 false,
                            		"	 false,
                            		"	 true,
                            		"	 ];
                            		"
                            		"	 uh oh, next statement is indented further!
                            
                            		" Note that this does *not* apply the line continuation pattern properly;
                            		" that's too hard to do correctly for my liking at present, so I'll just
                            		" start with these two main cases (square brackets and not returning to
                            		" column zero)
                            
                            		call cursor(a:lnum, 1)
                            		if searchpair('{\|(', '', '}\|)', 'nbW',
                            					\ 's:is_string_comment(line("."), col("."))') == 0
                            			if searchpair('\[', '', '\]', 'nbW',
                            						\ 's:is_string_comment(line("."), col("."))') == 0
                            				" Global scope, should be zero
                            				return 0
                            			else
                            				" At the module scope, inside square brackets only
                            				"if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
                            				if line =~ "^\\s*]"
                            					" It's the closing line, dedent it
                            					return 0
                            				else
                            					return shiftwidth()
                            				endif
                            			endif
                            		endif
                            	endif
                            
                            	" Fall back on cindent, which does it mostly right
                            	return cindent(a:lnum)
                            endfunction
                            
                            let &cpo = s:save_cpo
                            unlet s:save_cpo

SCRIPT  C:\tools\neovim\nvim-win64\share\nvim\runtime\syntax\rust.vim
Sourced 2 times
Total time:   0.002301
 Self time:   0.002301

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Rust
                            " Maintainer:   Patrick Walton <pcwalton@mozilla.com>
                            " Maintainer:   Ben Blum <bblum@cs.cmu.edu>
                            " Maintainer:   Chris Morgan <me@chrismorgan.info>
                            " Last Change:  Feb 24, 2016
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
    2              0.000009 if version < 600
                            	syntax clear
    2              0.000008 elseif exists("b:current_syntax")
                            	finish
    2              0.000001 endif
                            
                            " Syntax definitions {{{1
                            " Basic keywords {{{2
    2              0.000013 syn keyword   rustConditional match if else
    2              0.000006 syn keyword   rustRepeat for loop while
    2              0.000011 syn keyword   rustTypedef type nextgroup=rustIdentifier skipwhite skipempty
    2              0.000008 syn keyword   rustStructure struct enum nextgroup=rustIdentifier skipwhite skipempty
    2              0.000008 syn keyword   rustUnion union nextgroup=rustIdentifier skipwhite skipempty contained
    2              0.000265 syn match rustUnionContextual /\<union\_s\+\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*/ transparent contains=rustUnion
    2              0.000005 syn keyword   rustOperator    as
                            
    2              0.000012 syn match     rustAssert      "\<assert\(\w\)*!" contained
    2              0.000011 syn match     rustPanic       "\<panic\(\w\)*!" contained
    2              0.000004 syn keyword   rustKeyword     break
    2              0.000007 syn keyword   rustKeyword     box nextgroup=rustBoxPlacement skipwhite skipempty
    2              0.000004 syn keyword   rustKeyword     continue
    2              0.000011 syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite skipempty
    2              0.000006 syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite skipempty
    2              0.000005 syn keyword   rustKeyword     in impl let
    2              0.000006 syn keyword   rustKeyword     pub nextgroup=rustPubScope skipwhite skipempty
    2              0.000003 syn keyword   rustKeyword     return
    2              0.000004 syn keyword   rustSuper       super
    2              0.000004 syn keyword   rustKeyword     unsafe where
    2              0.000005 syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite skipempty
                            " FIXME: Scoped impl's name is also fallen in this category
    2              0.000006 syn keyword   rustKeyword     mod trait nextgroup=rustIdentifier skipwhite skipempty
    2              0.000006 syn keyword   rustStorage     move mut ref static const
    2              0.000018 syn match rustDefault /\<default\ze\_s\+\(impl\|fn\|type\|const\)\>/
                            
    2              0.000004 syn keyword   rustInvalidBareKeyword crate
                            
    2              0.000005 syn keyword rustPubScopeCrate crate contained
    2              0.000009 syn match rustPubScopeDelim /[()]/ contained
    2              0.000017 syn match rustPubScope /([^()]*)/ contained contains=rustPubScopeDelim,rustPubScopeCrate,rustSuper,rustModPath,rustModPathSep,rustSelf transparent
                            
    2              0.000008 syn keyword   rustExternCrate crate contained nextgroup=rustIdentifier,rustExternCrateString skipwhite skipempty
                            " This is to get the `bar` part of `extern crate "foo" as bar;` highlighting.
    2              0.000014 syn match   rustExternCrateString /".*"\_s*as/ contained nextgroup=rustIdentifier skipwhite transparent skipempty contains=rustString,rustOperator
    2              0.000006 syn keyword   rustObsoleteExternMod mod contained nextgroup=rustIdentifier skipwhite skipempty
                            
    2              0.000020 syn match     rustIdentifier  contains=rustIdentifierPrime "\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
    2              0.000013 syn match     rustFuncName    "\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
                            
    2              0.000017 syn region    rustBoxPlacement matchgroup=rustBoxPlacementParens start="(" end=")" contains=TOP contained
                            " Ideally we'd have syntax rules set up to match arbitrary expressions. Since
                            " we don't, we'll just define temporary contained rules to handle balancing
                            " delimiters.
    2              0.000012 syn region    rustBoxPlacementBalance start="(" end=")" containedin=rustBoxPlacement transparent
    2              0.000011 syn region    rustBoxPlacementBalance start="\[" end="\]" containedin=rustBoxPlacement transparent
                            " {} are handled by rustFoldBraces
                            
    2              0.000015 syn region rustMacroRepeat matchgroup=rustMacroRepeatDelimiters start="$(" end=")" contains=TOP nextgroup=rustMacroRepeatCount
    2              0.000008 syn match rustMacroRepeatCount ".\?[*+]" contained
    2              0.000007 syn match rustMacroVariable "$\w\+"
                            
                            " Reserved (but not yet used) keywords {{{2
    2              0.000013 syn keyword   rustReservedKeyword alignof become do offsetof priv pure sizeof typeof unsized yield abstract virtual final override macro
                            
                            " Built-in types {{{2
    2              0.000024 syn keyword   rustType        isize usize char bool u8 u16 u32 u64 u128 f32
    2              0.000006 syn keyword   rustType        f64 i8 i16 i32 i64 i128 str Self
                            
                            " Things from the libstd v1 prelude (src/libstd/prelude/v1.rs) {{{2
                            " This section is just straight transformation of the contents of the prelude,
                            " to make it easy to update.
                            
                            " Reexported core operators {{{3
    2              0.000005 syn keyword   rustTrait       Copy Send Sized Sync
    2              0.000005 syn keyword   rustTrait       Drop Fn FnMut FnOnce
                            
                            " Reexported functions {{{3
                            " There’s no point in highlighting these; when one writes drop( or drop::< it
                            " gets the same highlighting anyway, and if someone writes `let drop = …;` we
                            " don’t really want *that* drop to be highlighted.
                            "syn keyword rustFunction drop
                            
                            " Reexported types and traits {{{3
    2              0.000003 syn keyword rustTrait Box
    2              0.000003 syn keyword rustTrait ToOwned
    2              0.000003 syn keyword rustTrait Clone
    2              0.000005 syn keyword rustTrait PartialEq PartialOrd Eq Ord
    2              0.000004 syn keyword rustTrait AsRef AsMut Into From
    2              0.000003 syn keyword rustTrait Default
    2              0.000005 syn keyword rustTrait Iterator Extend IntoIterator
    2              0.000004 syn keyword rustTrait DoubleEndedIterator ExactSizeIterator
    2              0.000003 syn keyword rustEnum Option
    2              0.000004 syn keyword rustEnumVariant Some None
    2              0.000003 syn keyword rustEnum Result
    2              0.000004 syn keyword rustEnumVariant Ok Err
    2              0.000003 syn keyword rustTrait SliceConcatExt
    2              0.000004 syn keyword rustTrait String ToString
    2              0.000003 syn keyword rustTrait Vec
                            
                            " Other syntax {{{2
    2              0.000003 syn keyword   rustSelf        self
    2              0.000004 syn keyword   rustBoolean     true false
                            
                            " If foo::bar changes to foo.bar, change this ("::" to "\.").
                            " If foo::bar changes to Foo::bar, change this (first "\w" to "\u").
    2              0.000015 syn match     rustModPath     "\w\(\w\)*::[^<]"he=e-3,me=e-3
    2              0.000005 syn match     rustModPathSep  "::"
                            
    2              0.000008 syn match     rustFuncCall    "\w\(\w\)*("he=e-1,me=e-1
    2              0.000008 syn match     rustFuncCall    "\w\(\w\)*::<"he=e-3,me=e-3 " foo::<T>();
                            
                            " This is merely a convention; note also the use of [A-Z], restricting it to
                            " latin identifiers rather than the full Unicode uppercase. I have not used
                            " [:upper:] as it depends upon 'noignorecase'
                            "syn match     rustCapsIdent    display "[A-Z]\w\(\w\)*"
                            
    2              0.000013 syn match     rustOperator     display "\%(+\|-\|/\|*\|=\|\^\|&\||\|!\|>\|<\|%\)=\?"
                            " This one isn't *quite* right, as we could have binary-& with a reference
    2              0.000013 syn match     rustSigil        display /&\s\+[&~@*][^)= \t\r\n]/he=e-1,me=e-1
    2              0.000010 syn match     rustSigil        display /[&~@*][^)= \t\r\n]/he=e-1,me=e-1
                            " This isn't actually correct; a closure with no arguments can be `|| { }`.
                            " Last, because the & in && isn't a sigil
    2              0.000006 syn match     rustOperator     display "&&\|||"
                            " This is rustArrowCharacter rather than rustArrow for the sake of matchparen,
                            " so it skips the ->; see http://stackoverflow.com/a/30309949 for details.
    2              0.000005 syn match     rustArrowCharacter display "->"
    2              0.000008 syn match     rustQuestionMark display "?\([a-zA-Z]\+\)\@!"
                            
    2              0.000020 syn match     rustMacro       '\w\(\w\)*!' contains=rustAssert,rustPanic
    2              0.000008 syn match     rustMacro       '#\w\(\w\)*' contains=rustAssert,rustPanic
                            
    2              0.000008 syn match     rustEscapeError   display contained /\\./
    2              0.000013 syn match     rustEscape        display contained /\\\([nrt0\\'"]\|x\x\{2}\)/
    2              0.000010 syn match     rustEscapeUnicode display contained /\\u{\x\{1,6}}/
    2              0.000007 syn match     rustStringContinuation display contained /\\\n\s*/
    2              0.000019 syn region    rustString      start=+b"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeError,rustStringContinuation
    2              0.000022 syn region    rustString      start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustStringContinuation,@Spell
    2              0.000014 syn region    rustString      start='b\?r\z(#*\)"' end='"\z1' contains=@Spell
                            
    2              0.000022 syn region    rustAttribute   start="#!\?\[" end="\]" contains=rustString,rustDerive,rustCommentLine,rustCommentBlock,rustCommentLineDocError,rustCommentBlockDocError
    2              0.000013 syn region    rustDerive      start="derive(" end=")" contained contains=rustDeriveTrait
                            " This list comes from src/libsyntax/ext/deriving/mod.rs
                            " Some are deprecated (Encodable, Decodable) or to be removed after a new snapshot (Show).
    2              0.000028 syn keyword   rustDeriveTrait contained Clone Hash RustcEncodable RustcDecodable Encodable Decodable PartialEq Eq PartialOrd Ord Rand Show Debug Default FromPrimitive Send Sync Copy
                            
                            " Number literals
    2              0.000023 syn match     rustDecNumber   display "\<[0-9][0-9_]*\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    2              0.000020 syn match     rustHexNumber   display "\<0x[a-fA-F0-9_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    2              0.000015 syn match     rustOctNumber   display "\<0o[0-7_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    2              0.000012 syn match     rustBinNumber   display "\<0b[01_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
                            
                            " Special case for numbers of the form "1." which are float literals, unless followed by
                            " an identifier, which makes them integer literals with a method call or field access,
                            " or by another ".", which makes them integer literals followed by the ".." token.
                            " (This must go first so the others take precedence.)
    2              0.000015 syn match     rustFloat       display "\<[0-9][0-9_]*\.\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\|\.\)\@!"
                            " To mark a number as a normal float, it must have at least one of the three things integral values don't have:
                            " a decimal point and more numbers; an exponent; and a type suffix.
    2              0.000015 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)\="
    2              0.000018 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\(f32\|f64\)\="
    2              0.000015 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)"
                            
                            " For the benefit of delimitMate
    2              0.000031 syn region rustLifetimeCandidate display start=/&'\%(\([^'\\]\|\\\(['nrt0\\\"]\|x\x\{2}\|u{\x\{1,6}}\)\)'\)\@!/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
    2              0.000023 syn region rustGenericRegion display start=/<\%('\|[^[cntrl:][:space:][:punct:]]\)\@=')\S\@=/ end=/>/ contains=rustGenericLifetimeCandidate
    2              0.000022 syn region rustGenericLifetimeCandidate display start=/\%(<\|,\s*\)\@<='/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
                            
                            "rustLifetime must appear before rustCharacter, or chars will get the lifetime highlighting
    2              0.000017 syn match     rustLifetime    display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*"
    2              0.000017 syn match     rustLabel       display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*:"
    2              0.000012 syn match   rustCharacterInvalid   display contained /b\?'\zs[\n\r\t']\ze'/
                            " The groups negated here add up to 0-255 but nothing else (they do not seem to go beyond ASCII).
    2              0.000020 syn match   rustCharacterInvalidUnicode   display contained /b'\zs[^[:cntrl:][:graph:][:alnum:][:space:]]\ze'/
    2              0.000018 syn match   rustCharacter   /b'\([^\\]\|\\\(.\|x\x\{2}\)\)'/ contains=rustEscape,rustEscapeError,rustCharacterInvalid,rustCharacterInvalidUnicode
    2              0.000020 syn match   rustCharacter   /'\([^\\]\|\\\(.\|x\x\{2}\|u{\x\{1,6}}\)\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid
                            
    2              0.000009 syn match rustShebang /\%^#![^[].*/
    2              0.000014 syn region rustCommentLine                                                  start="//"                      end="$"   contains=rustTodo,@Spell
    2              0.000014 syn region rustCommentLineDoc                                               start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell
    2              0.000015 syn region rustCommentLineDocError                                          start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell contained
    2              0.000022 syn region rustCommentBlock             matchgroup=rustCommentBlock         start="/\*\%(!\|\*[*/]\@!\)\@!" end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell
    2              0.000018 syn region rustCommentBlockDoc          matchgroup=rustCommentBlockDoc      start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNest,@Spell
    2              0.000018 syn region rustCommentBlockDocError     matchgroup=rustCommentBlockDocError start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained
    2              0.000031 syn region rustCommentBlockNest         matchgroup=rustCommentBlock         start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell contained transparent
    2              0.000016 syn region rustCommentBlockDocNest      matchgroup=rustCommentBlockDoc      start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNest,@Spell contained transparent
    2              0.000015 syn region rustCommentBlockDocNestError matchgroup=rustCommentBlockDocError start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained transparent
                            " FIXME: this is a really ugly and not fully correct implementation. Most
                            " importantly, a case like ``/* */*`` should have the final ``*`` not being in
                            " a comment, but in practice at present it leaves comments open two levels
                            " deep. But as long as you stay away from that particular case, I *believe*
                            " the highlighting is correct. Due to the way Vim's syntax engine works
                            " (greedy for start matches, unlike Rust's tokeniser which is searching for
                            " the earliest-starting match, start or end), I believe this cannot be solved.
                            " Oh you who would fix it, don't bother with things like duplicating the Block
                            " rules and putting ``\*\@<!`` at the start of them; it makes it worse, as
                            " then you must deal with cases like ``/*/**/*/``. And don't try making it
                            " worse with ``\%(/\@<!\*\)\@<!``, either...
                            
    2              0.000006 syn keyword rustTodo contained TODO FIXME XXX NB NOTE
                            
                            " Folding rules {{{2
                            " Trivial folding rules to begin with.
                            " FIXME: use the AST to make really good folding
    2              0.000009 syn region rustFoldBraces start="{" end="}" transparent fold
                            
                            " Default highlighting {{{1
    2              0.000251 hi def link rustDecNumber       rustNumber
    2              0.000006 hi def link rustHexNumber       rustNumber
    2              0.000003 hi def link rustOctNumber       rustNumber
    2              0.000003 hi def link rustBinNumber       rustNumber
    2              0.000003 hi def link rustIdentifierPrime rustIdentifier
    2              0.000003 hi def link rustTrait           rustType
    2              0.000003 hi def link rustDeriveTrait     rustTrait
                            
    2              0.000004 hi def link rustMacroRepeatCount   rustMacroRepeatDelimiters
    2              0.000003 hi def link rustMacroRepeatDelimiters   Macro
    2              0.000003 hi def link rustMacroVariable Define
    2              0.000003 hi def link rustSigil         StorageClass
    2              0.000003 hi def link rustEscape        Special
    2              0.000003 hi def link rustEscapeUnicode rustEscape
    2              0.000003 hi def link rustEscapeError   Error
    2              0.000003 hi def link rustStringContinuation Special
    2              0.000003 hi def link rustString        String
    2              0.000003 hi def link rustCharacterInvalid Error
    2              0.000004 hi def link rustCharacterInvalidUnicode rustCharacterInvalid
    2              0.000003 hi def link rustCharacter     Character
    2              0.000003 hi def link rustNumber        Number
    2              0.000003 hi def link rustBoolean       Boolean
    2              0.000003 hi def link rustEnum          rustType
    2              0.000003 hi def link rustEnumVariant   rustConstant
    2              0.000003 hi def link rustConstant      Constant
    2              0.000003 hi def link rustSelf          Constant
    2              0.000003 hi def link rustFloat         Float
    2              0.000003 hi def link rustArrowCharacter rustOperator
    2              0.000003 hi def link rustOperator      Operator
    2              0.000003 hi def link rustKeyword       Keyword
    2              0.000004 hi def link rustTypedef       Keyword " More precise is Typedef, but it doesn't feel right for Rust
    2              0.000003 hi def link rustStructure     Keyword " More precise is Structure
    2              0.000003 hi def link rustUnion         rustStructure
    2              0.000003 hi def link rustPubScopeDelim Delimiter
    2              0.000003 hi def link rustPubScopeCrate rustKeyword
    2              0.000003 hi def link rustSuper         rustKeyword
    2              0.000003 hi def link rustReservedKeyword Error
    2              0.000003 hi def link rustRepeat        Conditional
    2              0.000003 hi def link rustConditional   Conditional
    2              0.000003 hi def link rustIdentifier    Identifier
    2              0.000003 hi def link rustCapsIdent     rustIdentifier
    2              0.000003 hi def link rustModPath       Include
    2              0.000003 hi def link rustModPathSep    Delimiter
    2              0.000004 hi def link rustFunction      Function
    2              0.000003 hi def link rustFuncName      Function
    2              0.000003 hi def link rustFuncCall      Function
    2              0.000042 hi def link rustShebang       Comment
    2              0.000003 hi def link rustCommentLine   Comment
    2              0.000003 hi def link rustCommentLineDoc SpecialComment
    2              0.000003 hi def link rustCommentLineDocError Error
    2              0.000003 hi def link rustCommentBlock  rustCommentLine
    2              0.000003 hi def link rustCommentBlockDoc rustCommentLineDoc
    2              0.000003 hi def link rustCommentBlockDocError Error
    2              0.000003 hi def link rustAssert        PreCondit
    2              0.000003 hi def link rustPanic         PreCondit
    2              0.000003 hi def link rustMacro         Macro
    2              0.000003 hi def link rustType          Type
    2              0.000003 hi def link rustTodo          Todo
    2              0.000003 hi def link rustAttribute     PreProc
    2              0.000003 hi def link rustDerive        PreProc
    2              0.000003 hi def link rustDefault       StorageClass
    2              0.000003 hi def link rustStorage       StorageClass
    2              0.000044 hi def link rustObsoleteStorage Error
    2              0.000003 hi def link rustLifetime      Special
    2              0.000003 hi def link rustLabel         Label
    2              0.000003 hi def link rustInvalidBareKeyword Error
    2              0.000003 hi def link rustExternCrate   rustKeyword
    2              0.000003 hi def link rustObsoleteExternMod Error
    2              0.000003 hi def link rustBoxPlacementParens Delimiter
    2              0.000003 hi def link rustQuestionMark  Special
                            
                            " Other Suggestions:
                            " hi rustAttribute ctermfg=cyan
                            " hi rustDerive ctermfg=cyan
                            " hi rustAssert ctermfg=yellow
                            " hi rustPanic ctermfg=red
                            " hi rustMacro ctermfg=magenta
                            
    2              0.000005 syn sync minlines=200
    2              0.000003 syn sync maxlines=500
                            
    2              0.000015 let b:current_syntax = "rust"

SCRIPT  C:\tools\neovim\nvim-win64\share\nvim\runtime\ftplugin\vim.vim
Sourced 1 time
Total time:   0.000556
 Self time:   0.000556

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2023 Feb 07
                            
                            " Only do this when not done yet for this buffer
    1              0.000009 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
                            " Don't load another plugin for this buffer
    1              0.000003 let b:did_ftplugin = 1
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000003 if !exists('*VimFtpluginUndo')
    1              0.000006   func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< keywordprg<
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! vunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! vunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! vunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! vunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! vunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! vunmap <buffer> ["
                                 endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
    1              0.000001 endif
                            
    1              0.000003 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000008 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    1              0.000033 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    1              0.000004 setlocal keywordprg=:help
                            
                            " if "\n" .. getline(1, 10)->join("\n") =~# '\n\s*vim9\%[script]\>'
    1              0.000089 if "\n" .. join(getline(1, 10), "\n") =~# '\n\s*vim9\%[script]\>'
                              " Set 'comments' to format dashed lists in comments
                              setlocal com=sO:#\ -,mO:#\ \ ,eO:##,:#
                              " Comments starts with # in Vim9 script
                              setlocal commentstring=#%s
    1              0.000001 else
    1              0.000007   setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                              " Comments starts with a double quote in legacy script
    1              0.000003   setlocal commentstring=\"%s
    1              0.000001 endif
                            
                            
                            " Format comments to be up to 78 characters long
    1              0.000002 if &tw == 0
    1              0.000007   setlocal tw=78
    1              0.000001 endif
                            
                            " Prefer Vim help instead of manpages.
    1              0.000003 setlocal keywordprg=:help
                            
    1              0.000005 if !exists("no_plugin_maps") && !exists("no_vim_maps")
    1              0.000003   let b:did_add_maps = 1
                            
                              " Move around functions.
    1              0.000017   nnoremap <silent><buffer> [[ m':call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000020   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000014   nnoremap <silent><buffer> ]] m':call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000018   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000015   nnoremap <silent><buffer> [] m':call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000019   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000014   nnoremap <silent><buffer> ][ m':call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
    1              0.000019   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
                            
                              " Move around comments
    1              0.000013   nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000018   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000013   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000018   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000001 endif
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000003 if exists("loaded_matchit")
                              let b:match_ignorecase = 0
                              " "func" can also be used as a type:
                              "   var Ref: func
                              " or to list functions:
                              "   func name
                              " require a parenthesis following, then there can be an "endfunc".
                              let b:match_words =
                            	\ '\<\%(fu\%[nction]\|def\)!\=\s\+\S\+\s*(:\%(\%(^\||\)\s*\)\@<=\<retu\%[rn]\>:\%(\%(^\||\)\s*\)\@<=\<\%(endf\%[unction]\|enddef\)\>,' ..
                            	\ '\<\%(wh\%[ile]\|for\)\>:\%(\%(^\||\)\s*\)\@<=\<brea\%[k]\>:\%(\%(^\||\)\s*\)\@<=\<con\%[tinue]\>:\%(\%(^\||\)\s*\)\@<=\<end\%(w\%[hile]\|fo\%[r]\)\>,' ..
                            	\ '\<if\>:\%(\%(^\||\)\s*\)\@<=\<el\%[seif]\>:\%(\%(^\||\)\s*\)\@<=\<en\%[dif]\>,' ..
                            	\ '{:},' ..
                            	\ '\<try\>:\%(\%(^\||\)\s*\)\@<=\<cat\%[ch]\>:\%(\%(^\||\)\s*\)\@<=\<fina\%[lly]\>:\%(\%(^\||\)\s*\)\@<=\<endt\%[ry]\>,' ..
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' ..
                            	\ '\<class\>:\<endclass\>,' ..
                            	\ '\<inte\%[rface]\>:\<endinterface\>,' ..
                            	\ '\<enu\%[m]\>:\<endenum\>,'
                            
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
                              " Also ignore here-doc and dictionary keys (vimVar).
                              let b:match_skip = 'synIDattr(synID(line("."), col("."), 1), "name")
                            	\ =~? "comment\\|string\\|vimSynReg\\|vimSet\\|vimLetHereDoc\\|vimVar"'
    1              0.000001 endif
                            
    1              0.000008 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  C:\tools\neovim\nvim-win64\share\nvim\runtime\indent\vim.vim
Sourced 1 time
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2022 Jun 24
                            
                            " Only load this indent file when no other was loaded.
    1              0.000005 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_indent = 1
                            
    1              0.000006 setlocal indentexpr=GetVimIndent()
    1              0.000005 setlocal indentkeys+==endif,=enddef,=endfu,=endfor,=endwh,=endtry,=},=else,=cat,=finall,=END,0\\,0=\"\\\ 
    1              0.000004 setlocal indentkeys-=0#
    1              0.000003 setlocal indentkeys-=:
                            
    1              0.000003 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetVimIndent")
                              finish
    1              0.000001 endif
    1              0.000006 let s:keepcpo= &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000002 function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
                            " Legacy script line continuation and Vim9 script operators that must mean an
                            " expression that continues from the previous line.
    1              0.000002 let s:lineContPat = '^\s*\(\\\|"\\ \|->\)'
                            
    1              0.000002 function GetVimIndentIntern()
                              " If the current line has line continuation and the previous one too, use
                              " the same indent.  This does not skip empty lines.
                              let cur_text = getline(v:lnum)
                              let cur_has_linecont = cur_text =~ s:lineContPat
                              if cur_has_linecont && v:lnum > 1 && getline(v:lnum - 1) =~ s:lineContPat
                                return indent(v:lnum - 1)
                              endif
                            
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " The previous line, ignoring line continuation
                              let prev_text_end = lnum > 0 ? getline(lnum) : ''
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
                              if !cur_has_linecont
                                while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " the start of the previous line, skipping over line continuation
                              let prev_text = getline(lnum)
                              let found_cont = 0
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                            
                              " In heredoc indenting works completely differently.
                              if has('syntax_items') 
                                let syn_here = synIDattr(synID(v:lnum, 1, 1), "name")
                                if syn_here =~ 'vimLetHereDocStop'
                                  " End of heredoc: use indent of matching start line
                                  let lnum = v:lnum - 1
                                  while lnum > 0
                            	let attr = synIDattr(synID(lnum, 1, 1), "name")
                            	if attr != '' && attr !~ 'vimLetHereDoc'
                            	  return indent(lnum)
                            	endif
                            	let lnum -= 1
                                  endwhile
                                  return 0
                                endif
                                if syn_here =~ 'vimLetHereDoc'
                                  if synIDattr(synID(lnum, 1, 1), "name") !~ 'vimLetHereDoc'
                            	" First line in heredoc: increase indent
                            	return ind + shiftwidth()
                                  endif
                                  " Heredoc continues: no change in indent
                                  return ind
                                endif
                              endif
                            
                              if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                let found_cont = 1
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                " A { may start a block or a dict.  Assume that when a } follows it's a
                                " terminated dict.
                                " ":function" starts a block but "function(" doesn't.
                                if prev_text !~ '^\s*au\%[tocmd]' && prev_text !~ '^\s*{.*}'
                                  let i = match(prev_text, '\(^\||\)\s*\(export\s\+\)\?\({\|\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\|finall\%[y]\|def\|el\%[seif]\)\>\|fu\%[nction][! ]\)')
                                  if i >= 0
                                    let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\|PatSep\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                              " For a line starting with "}" find the matching "{".  Align with that line,
                              " it is either the matching block start or dictionary start.
                              " Use the mapped "%" from matchit to find the match, otherwise we may match
                              " a { inside a comment or string.
                              if cur_text =~ '^\s*}'
                                if maparg('%') != ''
                                  exe v:lnum
                                  silent! normal %
                                  if line('.') < v:lnum
                            	let ind = indent('.')
                                  endif
                                else
                                  " todo: use searchpair() to find a match
                                endif
                              endif
                            
                              " Look back for a line to align with
                              while lnum > 1
                                " Below a line starting with "}" find the matching "{".
                                if prev_text =~ '^\s*}'
                                  if maparg('%') != ''
                            	exe lnum
                            	silent! normal %
                            	if line('.') < lnum
                            	  let lnum = line('.')
                            	  let ind = indent(lnum)
                            	  let prev_text = getline(lnum)
                            	else
                            	  break
                            	endif
                                  else
                            	" todo: use searchpair() to find a match
                            	break
                                  endif
                                elseif prev_text =~ s:lineContPat
                                  " looks like a continuation like, go back one line
                                  let lnum = lnum - 1
                                  let ind = indent(lnum)
                                  let prev_text = getline(lnum)
                                else
                                  break
                                endif
                              endwhile
                            
                              " Below a line starting with "]" we must be below the end of a list.
                              " Include a "}" and "},} in case a dictionary ends too.
                              if prev_text_end =~ '^\s*\(},\=\s*\)\=]'
                                let ind = ind - shiftwidth()
                              endif
                            
                              let ends_in_comment = has('syntax_items')
                            	\ && synIDattr(synID(lnum, len(getline(lnum)), 1), "name") =~ '\(Comment\|String\)$'
                            
                              " A line ending in "{" or "[" is most likely the start of a dict/list literal,
                              " indent the next line more.  Not for a continuation line or {{{.
                              if !ends_in_comment && prev_text_end =~ '\s[{[]\s*$' && !found_cont
                                let ind = ind + shiftwidth()
                              endif
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :endfor, :catch, :finally,
                              " :endtry, :endfun, :enddef, :else and :augroup END.
                              " Although ":en" would be enough only match short command names as in
                              " 'indentkeys'.
                              if cur_text =~ '^\s*\(endif\|endwh\|endfor\|endtry\|endfu\|enddef\|cat\|finall\|else\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                                if ind < 0
                                  let ind = 0
                                endif
                              endif
                            
                              return ind
                            endfunction
                            
    1              0.000008 let &cpo = s:keepcpo
    1              0.000002 unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  C:\tools\neovim\nvim-win64\share\nvim\runtime\syntax\vim.vim
Sourced 1 time
Total time:   0.021026
 Self time:   0.018410

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    1              0.000006 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
    1              0.000005 let s:keepcpo = &cpo
    1              0.000006 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    1              0.000008 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    1              0.000007 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    1              0.000010 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    1              0.000007 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    1              0.000013 syn keyword vimStdPlugin contained Arguments Asm Break Cfilter Clear Continue DiffOrig Evaluate Finish Gdb Lfilter Man N[ext] Over P[rint] Program Run S Source Step Stop Termdebug TermdebugCommand TOhtml Until Winbar XMLent XMLns
                            
                            " Vim-specific options {{{2
    1              0.000013 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    1              0.000008 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    1              0.000007 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    1              0.000030 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_Ds t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_KH t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_Us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    1              0.000005 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_ds t_EI t_kh t_kI
    1              0.000004 syn match   vimTermOption contained	"t_%1"
    1              0.000003 syn match   vimTermOption contained	"t_#2"
    1              0.000003 syn match   vimTermOption contained	"t_#4"
    1              0.000003 syn match   vimTermOption contained	"t_@7"
    1              0.000003 syn match   vimTermOption contained	"t_*7"
    1              0.000003 syn match   vimTermOption contained	"t_&8"
    1              0.000003 syn match   vimTermOption contained	"t_%i"
    1              0.000003 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    1              0.000004 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600
                            "}}}2
    1              0.000002 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    1              0.000018 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo
                            
                            " Default highlighting groups {{{2
    1              0.000025 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineFold CursorLineNr CursorLineSign DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu MessageWindow ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question QuickFixLine Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu
    1              0.000004 syn match vimHLGroup contained	"Conceal"
    1              0.000005 syn keyword vimOnlyHLGroup contained	LineNrAbove LineNrBelow StatusLineTerm Terminal VisualNOS
    1              0.000004 syn keyword nvimHLGroup contained	Substitute TermCursor TermCursorNC
                            "}}}2
    1              0.000002 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands {{{2
    1              0.000006 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[afhlmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'h'
                              com! -nargs=* VimFoldh <args> fold
                             else
                              com! -nargs=* VimFoldh <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p'
                              com! -nargs=* VimFoldp <args> fold
                             else
                              com! -nargs=* VimFoldp <args>
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
    1              0.000001 else
    1              0.000022  com! -nargs=*	VimFolda	<args>
    1              0.000010  com! -nargs=*	VimFoldf	<args>
    1              0.000007  com! -nargs=*	VimFoldh	<args>
    1              0.000007  com! -nargs=*	VimFoldl	<args>
    1              0.000007  com! -nargs=*	VimFoldm	<args>
    1              0.000007  com! -nargs=*	VimFoldp	<args>
    1              0.000007  com! -nargs=*	VimFoldP	<args>
    1              0.000007  com! -nargs=*	VimFoldr	<args>
    1              0.000008  com! -nargs=*	VimFoldt	<args>
    1              0.000001 endif
                            
                            " Deprecated variable options {{{2
    1              0.000004 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
    1              0.000001 endif
    1              0.000002 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
    1              0.000001 endif
    1              0.000003 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
    1              0.000001 endif
                            
                            " Variable options {{{2
    1              0.000002 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
    1              0.000001 else
    1              0.000003  let s:vimsyn_maxlines= 60
    1              0.000001 endif
                            
                            " Numbers {{{2
                            " =======
    1              0.000025 syn match vimNumber	'\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=' skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000010 syn match vimNumber	'-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\='  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000008 syn match vimNumber	'\<0[xX]\x\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000009 syn match vimNumber	'\%(^\|\A\)\zs#\x\{6}'             	       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000024 syn match vimNumber	'\<0[zZ][a-zA-Z0-9.]\+'                    skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000006 syn match vimNumber	'0[0-7]\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000007 syn match vimNumber	'0[bB][01]\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
                            
                            " All vimCommands are contained by vimIsCommand. {{{2
    1              0.000012 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimEcho,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    1              0.000004 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    1              0.000004 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"
    1              0.000006 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000004 syn match vimVar	      	"\s\zs&\a\+\>"
    1              0.000005 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000002 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            "   (buftype != nofile test avoids having append, change, insert show up in the command window)
                            " =======================
    1              0.000013 if &buftype != 'nofile'
                             syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$""
                             syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$""
                             syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$""
    1              0.000001 endif
                            
                            " Behave! {{{2
                            " =======
    1              0.000006 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    1              0.000002 syn keyword vimBehaveModel contained	mswin	xterm
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    1              0.000003  syn match   vimBehaveError contained	"[^ ]\+"
    1              0.000001 endif
                            
                            " Filetypes {{{2
                            " =========
    1              0.000010 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    1              0.000003  syn match   vimFTError  contained	"\I\i*"
    1              0.000001 endif
    1              0.000002 syn keyword vimFTCmd    contained	filet[ype]
    1              0.000003 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    1              0.000043 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimNotFunc,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vim9Comment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vim9Comment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue,vimSetEqual,vimOption
    1              0.000004 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
    1              0.000002 else
    1              0.000012  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    1              0.000001 endif
    1              0.000004 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    1              0.000007  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    1              0.000001 endif
    1              0.000003 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    1              0.000011 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimType,vimRegister,vimContinue,vim9Comment,vimVar
    1              0.000005 syn match	vimOper	"||\|&&\|[-+.!]"				skipwhite nextgroup=vimString,vimSpecFile
    1              0.000016 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\|!\~#\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000007 syn match	vimOper	"\(\<is\|\<isnot\)[?#]\{0,2}\>"			skipwhite nextgroup=vimString,vimSpecFile
    1              0.000007 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=vimoperStar,@vimOperGroup
    1              0.000008 syn region	vimOperParen	matchgroup=vimSep		start="#\={" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    1              0.000002  syn match	vimOperError	")"
    1              0.000001 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    1              0.000008 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    1              0.000042 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vim9Comment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimEnvvar,vimExecute,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLetHereDoc,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSearch,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    1              0.000073 syn match	vimFunction	"\<\(fu\%[nction]\)!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
    1              0.000007  syn match	vimFunction	"\<def!\=\ze\s*(" contains=@vimFuncList nextgroup=vimFuncBody
                            
    1              0.000014 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\|enddef\>\)"		contains=@vimFuncBodyList
    1              0.000001 else
    1              0.000010  syn region	vimFuncBody  contained	start="\ze\s*("		matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\|enddef\>\)"		contains=@vimFuncBodyList
    1              0.000001 endif
    1              0.000006 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    1              0.000004 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    1              0.000003 syn keyword	vimFuncKey   contained	fu[nction]
    1              0.000005 syn match	vimFuncBlank contained	"\s\+"
                            
    1              0.000003 syn keyword	vimPattern   contained	start	skip	end
                            
                            " vimTypes : new for vim9
    1              0.000013  syn match	vimType	":\s*\zs\<\(bool\|number\|float\|string\|blob\|list<\|dict<\|job\|channel\|func\)\>"
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    1              0.000007 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000006 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000005 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000004 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000004 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000005 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000004 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    1              0.000030 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vim9Comment,vimCtrlChar,vimEscapeBrace,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    1              0.000003 syn keyword	vimUserCommand	contained	com[mand]
    1              0.000009 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList,vimComFilter
    1              0.000003 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    1              0.000005 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    1              0.000007 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    1              0.000006 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000006 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000004 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    1              0.000004 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    1              0.000005 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    1              0.000005 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    1              0.000003  syn match	vimUserCmdError	contained	"\S\+\>"
    1              0.000001 endif
    1              0.000002 syn case ignore
    1              0.000010 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    1              0.000014 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    1              0.000005 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    1              0.000009 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    1              0.000002 syn case match
    1              0.000003 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    1              0.000008 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000006 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000005 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    1              0.000005 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            " Vim9 comments - TODO: might be highlighted while they don't work
    1              0.000013 syn match	vim9Comment	excludenl +\s#[^{].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000006 syn match	vim9Comment	+\<endif\s\+#[^{].*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000005 syn match	vim9Comment	+\<else\s\+#[^{].*$+lc=4	contains=@vimCommentGroup,vimCommentString
                            " Vim9 comment inside expression
    1              0.000005 syn match	vim9Comment	+\s\zs#[^{].*$+ms=s+1	contains=@vimCommentGroup,vimCommentString
    1              0.000005 syn match	vim9Comment	+^\s*#[^{].*$+	contains=@vimCommentGroup,vimCommentString
    1              0.000004 syn match	vim9Comment	+^\s*#$+	contains=@vimCommentGroup,vimCommentString
                            
                            " Environment Variables: {{{2
                            " =====================
    1              0.000003 syn match	vimEnvvar	"\$\I\i*"
    1              0.000003 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    1              0.000010 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    1              0.000003 syn match	vimPatSepErr	contained	"\\)"
    1              0.000003 syn match	vimPatSep	contained	"\\|"
    1              0.000011 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\\]['"]"	contains=@vimStringGroup
    1              0.000008 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    1              0.000003 syn match	vimNotPatSep	contained	"\\\\"
    1              0.000008 syn cluster	vimStringGroup	contains=vimEscape,vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    1              0.000009 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+	contains=@vimStringGroup
    1              0.000006 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    1              0.000007 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    1              0.000011 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
                            "syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup  " see tst45.vim
    1              0.000005 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    1              0.000004 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
    1              0.000002 syn match	vimEscape	contained	"\\."
                            
                            " Substitutions: {{{2
                            " =============
    1              0.000006 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    1              0.000005 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    1              0.000004 syn cluster	vimSubstList	add=vimCollection
    1              0.000023 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
                            "syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    1              0.000008 syn match	vimSubst	"\%(^\|[^\\\"']\)\<s\%[ubstitute]\>[:#[:alpha:]\"']\@!"	nextgroup=vimSubstPat contained
    1              0.000006 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    1              0.000008 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    1              0.000006 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000007 syn match	vimSubst2       contained	"s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000017 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    1              0.000013 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    1              0.000008 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    1              0.000004 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    1              0.000014 syn match	vimCollClass    contained transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    1              0.000003 syn match	vimSubstSubstr  contained	"\\z\=\d"
    1              0.000003 syn match	vimSubstTwoBS   contained	"\\\\"
    1              0.000005 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    1              0.000004 syn match	vimSubstFlags   contained	"[&cegiIlnpr#]\+"
                            
                            " 'String': {{{2
    1              0.000004 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    1              0.000007 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000006 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000005 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000005 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000006 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000005 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst2
    1              0.000004 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
    1              0.000006 syn match	vimRange	"[`'][a-zA-Z0-9],[`'][a-zA-Z0-9]"	contains=vimMark	skipwhite nextgroup=vimFilter
                            
    1              0.000006 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    1              0.000005 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    1              0.000004 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    1              0.000004 syn match	vimRegister	'@"'
    1              0.000004 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    1              0.000004 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    1              0.000004 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    1              0.000006 syn match	vimFilter 		"^!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000006 syn match	vimFilter    contained	"!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000007 syn match	vimComFilter contained	"|!!\=[^"]\{-}\(|\|\ze\"\|$\)"      contains=vimOper,vimSpecFile
                            
                            " Complex Repeats: (:h complex-repeat) {{{2
    1              0.000005 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    1              0.000005 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    1              0.000059 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\.\n\@!" end="$" end="|" matchgroup=vimNotation end="<[cC][rR]>" keepend contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vim9Comment,vimSetString,vimSetMod
    1              0.000019  syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]"me=e-1 end="$"	contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar
    1              0.000007 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+		contains=vimCtrlChar
    1              0.000003 syn match	vimSetSep	contained	"[,:]"
    1              0.000004 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let: {{{2
                            " ===
    1              0.000006 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar,vimLetHereDoc
    1              0.000017 VimFoldh syn region vimLetHereDoc matchgroup=vimLetHereDocStart start='=<<\s\+\%(trim\s\+\)\=\%(eval\s\+\)\=\s*\z(\L\S*\)' matchgroup=vimLetHereDocStop end='^\s*\z1\s*$'
                            
                            " Abbreviations: {{{2
                            " =============
    1              0.000011 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd: {{{2
                            " =======
    1              0.000009 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    1              0.000004 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    1              0.000004 syn match	vimAutoCmdSfxList	contained	"\S*"	skipwhite nextgroup=vimAutoCmdMod
    1              0.000007 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
    1              0.000005 syn match	vimAutoCmdMod	"\(++\)\=\(once\|nested\)"
                            
                            " Echo and Execute: -- prefer strings! {{{2
                            " ================
    1              0.000012 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    1              0.000015 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    1              0.000007 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    1              0.000002 syn case ignore
    1              0.000002 syn keyword	vimEchoHLNone	none
    1              0.000001 syn case match
                            
                            " Maps: {{{2
                            " ====
    1              0.000014 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000023 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] tno[remap] tm[ap] vm[ap] vmapc[lear] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000006 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000004 syn keyword	vimMap		mapc[lear] smapc[lear]
    1              0.000014 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000005 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000006 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    1              0.000004 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000015 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000006 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    1              0.000004 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    1              0.000002 syn case ignore
    1              0.000005 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    1              0.000001 syn case match
                            
                            " Menus: {{{2
                            " =====
    1              0.000008 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    1              0.000024 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] tlm[enu] tln[oremenu] tlu[nmenu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    1              0.000006 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    1              0.000004 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    1              0.000006 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    1              0.000009 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    1              0.000004 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    1              0.000005 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vim9Comment,vimIsCommand
    1              0.000003 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation: (tnx to Michael Geddes) {{{2
                            " ======================
    1              0.000003 syn case ignore
    1              0.000033 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cmd\|cr\|lf\|linefeed\|return\|enter\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|mouse\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    1              0.000012 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    1              0.000051 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"			contains=vimBracket
    1              0.000008 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    1              0.000011 syn match	vimNotation	'\%#=1\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    1              0.000008 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    1              0.000003 syn match	vimBracket contained	"[\\<>]"
    1              0.000002 syn case match
                            
                            " User Function Highlighting: {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    1              0.000041 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncEcho,vimFuncName,vimUserFunc,vimExecute
    1              0.000013 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
    1              0.000003 syn keyword vimFuncEcho contained	ec ech echo
                            
                            " User Command Highlighting: {{{2
    1              0.000009 syn match vimUsrCmd	'^\s*\zs\u\%(\w*\)\@>\%([(#[]\|\s\+\%([-+*/%]\=\|\.\.\)=\)\@!'
                            
                            " Errors And Warnings: {{{2
                            " ====================
    1              0.000007 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    1              0.000016  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
    1              0.000009  syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    1              0.000004  syn match	vimElseIfErr	"\<else\s\+if\>"
    1              0.000005  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    1              0.000001 endif
                            
    1              0.000009 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<retu\%[rn]\>\|\<while\>"	skipwhite nextgroup=vimOper,vimOperParen,vimVar,vimFunc,vimNotation
                            
                            " Norm: {{{2
                            " ====
    1              0.000004 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    1              0.000003 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax: {{{2
                            "=======
    1              0.000006 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    1              0.000006 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    1              0.000003 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    1              0.000003  syn match	vimSynError	contained	"\i\+"
    1              0.000004  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    1              0.000001 endif
    1              0.000008 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    1              0.000005 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    1              0.000004 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    1              0.000007 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment,vim9Comment
    1              0.000006 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment,vim9Comment
    1              0.000007 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    1              0.000004 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    1              0.000003  syn match	vimSynCaseError	contained	"\i\+"
    1              0.000001 endif
    1              0.000002 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    1              0.000003 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    1              0.000003 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    1              0.000013 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    1              0.000005 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    1              0.000006 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    1              0.000007 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    1              0.000004 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    1              0.000005 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    1              0.000003 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    1              0.000003 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    1              0.000005 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    1              0.000005 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    1              0.000003 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    1              0.000039 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    1              0.000009 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    1              0.000004 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    1              0.000009 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation,vim9Comment
    1              0.000003 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    1              0.000008 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    1              0.000011 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    1              0.000005 if has("conceal")
    1              0.000005  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    1              0.000003  syn match	vimSynMtchCchar	contained	"\S"
    1              0.000001 endif
    1              0.000004 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    1              0.000003 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    1              0.000009 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    1              0.000007 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    1              0.000003 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    1              0.000009 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    1              0.000013 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    1              0.000005 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    1              0.000006 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    1              0.000012 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    1              0.000007 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    1              0.000007 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    1              0.000003 syn match	vimSynPatMod	contained	"lc=\d\+"
    1              0.000004 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    1              0.000006 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    1              0.000003 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    1              0.000003 syn match	vimMtchComment	contained	'"[^"]\+$'
    1              0.000004 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    1              0.000009 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    1              0.000006 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    1              0.000003  syn match	vimSyncError	contained	"\i\+"
    1              0.000001 endif
    1              0.000003 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    1              0.000003 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    1              0.000003 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    1              0.000004 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    1              0.000003 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    1              0.000005 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    1              0.000007 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    1              0.000006 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    1              0.000004 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    1              0.000002 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand: here by reasons of precedence {{{2
                            " ====================
    1              0.000005 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting: {{{2
                            " ============
    1              0.000006 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment,vim9Comment
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    1              0.000003  syn match	vimHiCtermError	contained	"\D\i*"
    1              0.000001 endif
    1              0.000006 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    1              0.000003 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    1              0.000003 syn match	vimHiGroup	contained	"\i\+"
    1              0.000002 syn case ignore
    1              0.000011 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl underdouble underdotted underdashed
    1              0.000004 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    1              0.000002 syn case match
    1              0.000004 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    1              0.000004 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    1              0.000003 syn case ignore
    1              0.000014 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey grey40 grey50 grey90 lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred lightyellow magenta red seagreen white yellow
    1              0.000004 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    1              0.000001 syn case match
    1              0.000011 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    1              0.000006 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    1              0.000003 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    1              0.000014 syn cluster	vimHiCluster contains=vimGroup,vimHiBlend,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiCtermul,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    1              0.000010 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    1              0.000006 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    1              0.000003  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    1              0.000001 endif
    1              0.000004 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000006 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    1              0.000004 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000007 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000006 syn match	vimHiCtermul	contained	"\cctermul="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000004 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    1              0.000005 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    1              0.000007 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    1              0.000004 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    1              0.000004 syn match	vimHiBlend	contained	"\cblend="he=e-1		nextgroup=vimHiNmbr
    1              0.000003 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    1              0.000004 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
    1              0.000018 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=@vimHiCluster
    1              0.000005 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters: {{{2
                            " ==================
    1              0.000003 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    1              0.000007 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000056 syn match	vim9LineComment	+^[ \t:]\+#.*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000011 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    1              0.000003 syn match	vimContinue	"^\s*\\"
    1              0.000015 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    1              0.000003 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    1              0.000005 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    1              0.000004 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    1              0.000009 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    1              0.000008 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Embedded Scripts:  {{{2
                            " ================
                            "   perl,ruby     : Benoit Cerrina
                            "   python,tcl    : Johannes Zellner
                            "   mzscheme, lua : Charles Campbell
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    1              0.000004 if !exists("g:vimsyn_embed")
    1              0.000003  let g:vimsyn_embed = 'l'
    1              0.000001 endif
                            
                            " [-- lua --] {{{3
    1              0.000108 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    1              0.000275 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000083 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
    1              0.000003  unlet! b:current_syntax
    1              0.000007  syn cluster vimFuncBodyList	add=vimLuaRegion
    1   0.014785   0.012168  exe "syn include @vimLuaScript ".s:luapath
    1              0.000018  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
    1              0.000010  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+	contains=@vimLuaScript
    1              0.000005  syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
                             syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000002 unlet s:luapath
                            
                            " [-- perl --] {{{3
    1              0.000065 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    1              0.000283 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000006 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)\ze\(\s*["#].*\)\=$+ end=+^\z1\ze\(\s*[#"].*\)\=$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+			contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
    1              0.000001 else
    1              0.000011  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000006  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000002 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    1              0.000056 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    1              0.000124 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000006 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimRubyScript
                             syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+			contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
    1              0.000001 else
    1              0.000008  syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000005  syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000002 unlet s:rubypath
                            
                            " [-- python --] {{{3
    1              0.000056 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    1              0.000246 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000006 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\%(trim\s*\)\=\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\%(trim\s*\)\=$+ end=+\.$+				contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\%(trim\s*\)\=\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*\%(trim\s*\)\=$+ end=+\.$+				contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
    1              0.000001 else
    1              0.000010  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000016  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000002 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    1              0.000006 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
    1              0.000016  let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
                            else
                             let s:trytcl= 1
    1              0.000001 endif
    1              0.000002 if s:trytcl
    1              0.000057  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    1              0.000272  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
    1              0.000001  endif
    1              0.000006  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
    1              0.000001  else
    1              0.000009   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000018   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000001  endif
    1              0.000002  unlet s:tclpath
                            else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000002 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    1              0.000058 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    1              0.000265 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000006 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
    1              0.000001 else
    1              0.000010  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000008  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000002 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    1              0.000004 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
    1              0.000001 endif
    1              0.000008 exe "syn sync maxlines=".s:vimsyn_maxlines
    1              0.000005 syn sync linecont	"^\s\+\\"
    1              0.000009 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    1              0.000004 if !exists("skip_vim_syntax_inits")
    1              0.000003  if !exists("g:vimsyn_noerror")
    1              0.000003   hi def link vimBehaveError	vimError
    1              0.000002   hi def link vimCollClassErr	vimError
    1              0.000002   hi def link vimErrSetting	vimError
    1              0.000002   hi def link vimEmbedError	Normal
    1              0.000002   hi def link vimFTError	vimError
    1              0.000002   hi def link vimFunctionError	vimError
    1              0.000002   hi def link vimFunc         	vimError
    1              0.000002   hi def link vimHiAttribList	vimError
    1              0.000002   hi def link vimHiCtermError	vimError
    1              0.000002   hi def link vimHiKeyError	vimError
    1              0.000002   hi def link vimKeyCodeError	vimError
    1              0.000002   hi def link vimMapModErr	vimError
    1              0.000002   hi def link vimSubstFlagErr	vimError
    1              0.000002   hi def link vimSynCaseError	vimError
    1              0.000002   hi def link vimBufnrWarn	vimWarn
    1              0.000001  endif
                            
    1              0.000002  hi def link vimAbb	vimCommand
    1              0.000002  hi def link vimAddress	vimMark
    1              0.000002  hi def link vimAugroupError	vimError
    1              0.000002  hi def link vimAugroupKey	vimCommand
    1              0.000002  hi def link vimAuHighlight	vimHighlight
    1              0.000002  hi def link vimAutoCmdOpt	vimOption
    1              0.000002  hi def link vimAutoCmd	vimCommand
    1              0.000002  hi def link vimAutoEvent	Type
    1              0.000002  hi def link vimAutoCmdMod	Special
    1              0.000005  hi def link vimAutoSet	vimCommand
    1              0.000002  hi def link vimBehaveModel	vimBehave
    1              0.000001  hi def link vimBehave	vimCommand
    1              0.000002  hi def link vimBracket	Delimiter
    1              0.000002  hi def link vimCmplxRepeat	SpecialChar
    1              0.000010  hi def link vimCommand	Statement
    1              0.000002  hi def link vimComment	Comment
    1              0.000002  hi def link vim9Comment	Comment
    1              0.000002  hi def link vimCommentString	vimString
    1              0.000002  hi def link vimCommentTitle	PreProc
    1              0.000002  hi def link vimCondHL	vimCommand
    1              0.000002  hi def link vimContinue	Special
    1              0.000002  hi def link vimCtrlChar	SpecialChar
    1              0.000002  hi def link vimEchoHLNone	vimGroup
    1              0.000002  hi def link vimEchoHL	vimCommand
    1              0.000002  hi def link vimElseIfErr	Error
    1              0.000002  hi def link vimElseif	vimCondHL
    1              0.000002  hi def link vimEnvvar	PreProc
    1              0.000001  hi def link vimError	Error
    1              0.000002  hi def link vimEscape	Special
    1              0.000001  hi def link vimFBVar	vimVar
    1              0.000002  hi def link vimFgBgAttrib	vimHiAttrib
    1              0.000002  hi def link vimFuncEcho	vimCommand
    1              0.000002  hi def link vimHiCtermul	vimHiTerm
    1              0.000002  hi def link vimFold	Folded
    1              0.000001  hi def link vimFTCmd	vimCommand
    1              0.000002  hi def link vimFTOption	vimSynType
    1              0.000002  hi def link vimFuncKey	vimCommand
    1              0.000002  hi def link vimFuncName	Function
    1              0.000002  hi def link vimFuncSID	Special
    1              0.000002  hi def link vimFuncVar	Identifier
    1              0.000003  hi def link vimGroupAdd	vimSynOption
    1              0.000002  hi def link vimGroupName	vimGroup
    1              0.000002  hi def link vimGroupRem	vimSynOption
    1              0.000002  hi def link vimGroupSpecial	Special
    1              0.000001  hi def link vimGroup	Type
    1              0.000001  hi def link vimHiAttrib	PreProc
    1              0.000002  hi def link vimHiBlend	vimHiTerm
    1              0.000002  hi def link vimHiClear	vimHighlight
    1              0.000002  hi def link vimHiCtermFgBg	vimHiTerm
    1              0.000001  hi def link vimHiCTerm	vimHiTerm
    1              0.000001  hi def link vimHighlight	vimCommand
    1              0.000002  hi def link vimHiGroup	vimGroupName
    1              0.000002  hi def link vimHiGuiFgBg	vimHiTerm
    1              0.000002  hi def link vimHiGuiFont	vimHiTerm
    1              0.000002  hi def link vimHiGuiRgb	vimNumber
    1              0.000001  hi def link vimHiGui	vimHiTerm
    1              0.000002  hi def link vimHiNmbr	Number
    1              0.000002  hi def link vimHiStartStop	vimHiTerm
    1              0.000001  hi def link vimHiTerm	Type
    1              0.000001  hi def link vimHLGroup	vimGroup
    1              0.000002  hi def link vimHLMod	PreProc
    1              0.000002  hi def link vimInsert	vimString
    1              0.000001  hi def link vimIskSep	Delimiter
    1              0.000002  hi def link vimKeyCode	vimSpecFile
    1              0.000002  hi def link vimKeyword	Statement
    1              0.000002  hi def link vimLet	vimCommand
    1              0.000002  hi def link vimLetHereDoc	vimString
    1              0.000002  hi def link vimLetHereDocStart	Special
    1              0.000002  hi def link vimLetHereDocStop	Special
    1              0.000002  hi def link vimLineComment	vimComment
    1              0.000002  hi def link vim9LineComment	vimComment
    1              0.000002  hi def link vimMapBang	vimCommand
    1              0.000002  hi def link vimMapModKey	vimFuncSID
    1              0.000002  hi def link vimMapMod	vimBracket
    1              0.000002  hi def link vimMap	vimCommand
    1              0.000001  hi def link vimMark	Number
    1              0.000002  hi def link vimMarkNumber	vimNumber
    1              0.000002  hi def link vimMenuMod	vimMapMod
    1              0.000002  hi def link vimMenuNameMore	vimMenuName
    1              0.000001  hi def link vimMenuName	PreProc
    1              0.000002  hi def link vimMtchComment	vimComment
    1              0.000002  hi def link vimNorm	vimCommand
    1              0.000001  hi def link vimNotation	Special
    1              0.000002  hi def link vimNotFunc	vimCommand
    1              0.000002  hi def link vimNotPatSep	vimString
    1              0.000001  hi def link vimNumber	Number
    1              0.000002  hi def link vimOperError	Error
    1              0.000002  hi def link vimOper	Operator
    1              0.000001  hi def link vimOperStar	vimOper
    1              0.000001  hi def link vimOption	PreProc
    1              0.000001  hi def link vimParenSep	Delimiter
    1              0.000001  hi def link vimPatSepErr	vimError
    1              0.000002  hi def link vimPatSepR	vimPatSep
    1              0.000002  hi def link vimPatSep	SpecialChar
    1              0.000002  hi def link vimPatSepZone	vimString
    1              0.000001  hi def link vimPatSepZ	vimPatSep
    1              0.000002  hi def link vimPattern	Type
    1              0.000001  hi def link vimPlainMark	vimMark
    1              0.000002  hi def link vimPlainRegister	vimRegister
    1              0.000002  hi def link vimRegister	SpecialChar
    1              0.000001  hi def link vimScriptDelim	Comment
    1              0.000002  hi def link vimSearchDelim	Statement
    1              0.000001  hi def link vimSearch	vimString
    1              0.000002  hi def link vimSep	Delimiter
    1              0.000001  hi def link vimSetMod	vimOption
    1              0.000002  hi def link vimSetSep	Statement
    1              0.000001  hi def link vimSetString	vimString
    1              0.000002  hi def link vimSpecFile	Identifier
    1              0.000002  hi def link vimSpecFileMod	vimSpecFile
    1              0.000002  hi def link vimSpecial	Type
    1              0.000002  hi def link vimStatement	Statement
    1              0.000002  hi def link vimStringCont	vimString
    1              0.000001  hi def link vimString	String
    1              0.000001  hi def link vimStringEnd	vimString
    1              0.000002  hi def link vimSubst1	vimSubst
    1              0.000002  hi def link vimSubstDelim	Delimiter
    1              0.000002  hi def link vimSubstFlags	Special
    1              0.000002  hi def link vimSubstSubstr	SpecialChar
    1              0.000002  hi def link vimSubstTwoBS	vimString
    1              0.000001  hi def link vimSubst	vimCommand
    1              0.000001  hi def link vimSynCaseError	Error
    1              0.000001  hi def link vimSynCase	Type
    1              0.000002  hi def link vimSyncC	Type
    1              0.000002  hi def link vimSyncError	Error
    1              0.000002  hi def link vimSyncGroupName	vimGroupName
    1              0.000001  hi def link vimSyncGroup	vimGroupName
    1              0.000002  hi def link vimSyncKey	Type
    1              0.000001  hi def link vimSyncNone	Type
    1              0.000002  hi def link vimSynContains	vimSynOption
    1              0.000007  hi def link vimSynError	Error
    1              0.000002  hi def link vimSynKeyContainedin	vimSynContains
    1              0.000002  hi def link vimSynKeyOpt	vimSynOption
    1              0.000002  hi def link vimSynMtchGrp	vimSynOption
    1              0.000002  hi def link vimSynMtchOpt	vimSynOption
    1              0.000002  hi def link vimSynNextgroup	vimSynOption
    1              0.000002  hi def link vimSynNotPatRange	vimSynRegPat
    1              0.000001  hi def link vimSynOption	Special
    1              0.000002  hi def link vimSynPatRange	vimString
    1              0.000002  hi def link vimSynRegOpt	vimSynOption
    1              0.000001  hi def link vimSynRegPat	vimString
    1              0.000002  hi def link vimSynReg	Type
    1              0.000002  hi def link vimSyntax	vimCommand
    1              0.000001  hi def link vimSynType	vimSpecial
    1              0.000001  hi def link vimTodo	Todo
    1              0.000001  hi def link vimType	Type
    1              0.000001  hi def link vimUnmap	vimMap
    1              0.000002  hi def link vimUserAttrbCmpltFunc	Special
    1              0.000002  hi def link vimUserAttrbCmplt	vimSpecial
    1              0.000002  hi def link vimUserAttrbKey	vimOption
    1              0.000002  hi def link vimUserAttrb	vimSpecial
    1              0.000002  hi def link vimUserAttrbError	Error
    1              0.000001  hi def link vimUserCmdError	Error
    1              0.000002  hi def link vimUserCommand	vimCommand
    1              0.000001  hi def link vimUserFunc	Normal
    1              0.000001  hi def link vimVar	Identifier
    1              0.000001  hi def link vimWarn	WarningMsg
                            
    1              0.000002  hi def link nvimAutoEvent	vimAutoEvent
    1              0.000002  hi def link nvimHLGroup	vimHLGroup
    1              0.000001  hi def link nvimMap	vimMap
    1              0.000001  hi def link nvimUnmap	vimUnmap
    1              0.000001 endif
                            
                            " Current Syntax Variable: {{{2
    1              0.000003 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    1              0.000003 delc VimFolda
    1              0.000002 delc VimFoldf
    1              0.000001 delc VimFoldl
    1              0.000001 delc VimFoldm
    1              0.000001 delc VimFoldp
    1              0.000001 delc VimFoldP
    1              0.000001 delc VimFoldr
    1              0.000001 delc VimFoldt
    1              0.000010 let &cpo = s:keepcpo
    1              0.000002 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  C:\tools\neovim\nvim-win64\share\nvim\runtime\syntax/lua.vim
Sourced 1 time
Total time:   0.002608
 Self time:   0.002608

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
                            " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:  2022 Sep 07
                            " Options:      lua_version = 4 or 5
                            "               lua_subversion = 0 (for 4.0 or 5.0)
                            "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
                            "               the default is 5.3
                            
                            " quit when a syntax file was already loaded
    1              0.000007 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
                            
    1              0.000007 let s:cpo_save = &cpo
    1              0.000012 set cpo&vim
                            
    1              0.000003 if !exists("lua_version")
                              " Default is lua 5.3
    1              0.000002   let lua_version = 5
    1              0.000002   let lua_subversion = 3
                            elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    1              0.000001 endif
                            
    1              0.000002 syn case match
                            
                            " syncing method
    1              0.000003 syn sync minlines=1000
                            
    1              0.000002 if lua_version >= 5
    1              0.000005   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
    1              0.000003   syn keyword luaMetaMethod __eq __lt __le
    1              0.000003   syn keyword luaMetaMethod __index __newindex __call
    1              0.000002   syn keyword luaMetaMethod __metatable __mode __gc __tostring
    1              0.000001 endif
                            
    1              0.000004 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
    1              0.000002   syn keyword luaMetaMethod __mod __len
    1              0.000001 endif
                            
    1              0.000003 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000002   syn keyword luaMetaMethod __pairs
    1              0.000001 endif
                            
    1              0.000003 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
    1              0.000002   syn keyword luaMetaMethod __idiv __name
    1              0.000003   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
    1              0.000001 endif
                            
    1              0.000003 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
                              syn keyword luaMetaMethod __close
    1              0.000001 endif
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
                            
    1              0.000009 syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
    1              0.000003 syn match  luaParenError ")"
    1              0.000003 syn match  luaError "}"
    1              0.000007 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " Function declaration
    1              0.000012 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
                            
                            " else
    1              0.000004 syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
                            
                            " then ... end
    1              0.000007 syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
                            
                            " elseif ... then
    1              0.000007 syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
                            
                            " if ... then
    1              0.000008 syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
                            
                            " do ... end
    1              0.000007 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
                            " repeat ... until
    1              0.000007 syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
                            
                            " while ... do
    1              0.000008 syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000008 syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000003 syn keyword luaFor contained containedin=luaFor in
                            
                            " other keywords
    1              0.000003 syn keyword luaStatement return local break
    1              0.000004 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000003   syn keyword luaStatement goto
    1              0.000004   syn match luaLabel "::\I\i*::"
    1              0.000001 endif
                            
                            " operators
    1              0.000004 syn keyword luaOperator and or not
                            
    1              0.000003 if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
    1              0.000007   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
                            elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
                              syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
                            else
                              syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
    1              0.000001 endif
                            
                            " comments
    1              0.000003 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000006 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000012 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    1              0.000004 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000009   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000001 endif
                            
                            " first line may start with #!
    1              0.000003 syn match luaComment "\%^#!.*"
                            
    1              0.000003 syn keyword luaConstant nil
    1              0.000002 if lua_version > 4
    1              0.000003   syn keyword luaConstant true false
    1              0.000001 endif
                            
                            " strings
    1              0.000008 syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
    1              0.000002 if lua_version == 5
    1              0.000002   if lua_subversion == 0
                                syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    1              0.000001   else
    1              0.000002     if lua_subversion >= 2
    1              0.000006       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
    1              0.000001     endif
    1              0.000002     if lua_subversion >= 3
    1              0.000004       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
    1              0.000001     endif
    1              0.000009     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000001   endif
    1              0.000001 endif
    1              0.000020 syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000008 syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000004 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000008 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
                            " floating point number, starting with a dot, optional exponent
    1              0.000005 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000006 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000002 if lua_version >= 5
    1              0.000002   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    1              0.000002   elseif lua_subversion >= 2
    1              0.000007     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000001   endif
    1              0.000001 endif
                            
                            " tables
    1              0.000007 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
                            
                            " methods
    1              0.000004 syntax match luaFunc ":\@<=\k\+"
                            
                            " built-in functions
    1              0.000004 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000004 syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
                            
    1              0.000002 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    1              0.000002 elseif lua_version == 5
    1              0.000003   syn keyword luaFunc getmetatable setmetatable
    1              0.000003   syn keyword luaFunc ipairs pairs
    1              0.000003   syn keyword luaFunc pcall xpcall
    1              0.000003   syn keyword luaFunc _G loadfile rawequal require
    1              0.000002   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    1              0.000001   else
    1              0.000003     syn keyword luaFunc load select
    1              0.000005     syn match   luaFunc /\<package\.cpath\>/
    1              0.000031     syn match   luaFunc /\<package\.loaded\>/
    1              0.000005     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000005     syn match   luaFunc /\<package\.path\>/
    1              0.000012     syn match   luaFunc /\<package\.preload\>/
    1              0.000003     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    1              0.000002     elseif lua_subversion >= 2
    1              0.000003       syn keyword luaFunc _ENV rawlen
    1              0.000007       syn match   luaFunc /\<package\.config\>/
    1              0.000004       syn match   luaFunc /\<package\.preload\>/
    1              0.000005       syn match   luaFunc /\<package\.searchers\>/
    1              0.000005       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000001     endif
                            
    1              0.000002     if lua_subversion >= 3
    1              0.000007       syn match luaFunc /\<coroutine\.isyieldable\>/
    1              0.000001     endif
    1              0.000002     if lua_subversion >= 4
                                  syn keyword luaFunc warn
                                  syn match luaFunc /\<coroutine\.close\>/
    1              0.000001     endif
    1              0.000005     syn match luaFunc /\<coroutine\.running\>/
    1              0.000001   endif
    1              0.000005   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000004   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000005   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000004   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000004   syn match   luaFunc /\<coroutine\.yield\>/
                            
    1              0.000005   syn match   luaFunc /\<string\.byte\>/
    1              0.000004   syn match   luaFunc /\<string\.char\>/
    1              0.000004   syn match   luaFunc /\<string\.dump\>/
    1              0.000004   syn match   luaFunc /\<string\.find\>/
    1              0.000004   syn match   luaFunc /\<string\.format\>/
    1              0.000004   syn match   luaFunc /\<string\.gsub\>/
    1              0.000004   syn match   luaFunc /\<string\.len\>/
    1              0.000004   syn match   luaFunc /\<string\.lower\>/
    1              0.000004   syn match   luaFunc /\<string\.rep\>/
    1              0.000004   syn match   luaFunc /\<string\.sub\>/
    1              0.000004   syn match   luaFunc /\<string\.upper\>/
    1              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    1              0.000001   else
    1              0.000005     syn match luaFunc /\<string\.gmatch\>/
    1              0.000004     syn match luaFunc /\<string\.match\>/
    1              0.000004     syn match luaFunc /\<string\.reverse\>/
    1              0.000001   endif
    1              0.000002   if lua_subversion >= 3
    1              0.000004     syn match luaFunc /\<string\.pack\>/
    1              0.000004     syn match luaFunc /\<string\.packsize\>/
    1              0.000004     syn match luaFunc /\<string\.unpack\>/
    1              0.000004     syn match luaFunc /\<utf8\.char\>/
    1              0.000007     syn match luaFunc /\<utf8\.charpattern\>/
    1              0.000016     syn match luaFunc /\<utf8\.codes\>/
    1              0.000004     syn match luaFunc /\<utf8\.codepoint\>/
    1              0.000004     syn match luaFunc /\<utf8\.len\>/
    1              0.000004     syn match luaFunc /\<utf8\.offset\>/
    1              0.000001   endif
                            
    1              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    1              0.000002   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    1              0.000002   elseif lua_subversion >= 2
    1              0.000004     syn match luaFunc /\<table\.pack\>/
    1              0.000004     syn match luaFunc /\<table\.unpack\>/
    1              0.000002     if lua_subversion >= 3
    1              0.000004       syn match luaFunc /\<table\.move\>/
    1              0.000001     endif
    1              0.000001   endif
    1              0.000004   syn match   luaFunc /\<table\.concat\>/
    1              0.000004   syn match   luaFunc /\<table\.insert\>/
    1              0.000004   syn match   luaFunc /\<table\.sort\>/
    1              0.000030   syn match   luaFunc /\<table\.remove\>/
                            
    1              0.000002   if lua_subversion == 2
                                syn match   luaFunc /\<bit32\.arshift\>/
                                syn match   luaFunc /\<bit32\.band\>/
                                syn match   luaFunc /\<bit32\.bnot\>/
                                syn match   luaFunc /\<bit32\.bor\>/
                                syn match   luaFunc /\<bit32\.btest\>/
                                syn match   luaFunc /\<bit32\.bxor\>/
                                syn match   luaFunc /\<bit32\.extract\>/
                                syn match   luaFunc /\<bit32\.lrotate\>/
                                syn match   luaFunc /\<bit32\.lshift\>/
                                syn match   luaFunc /\<bit32\.replace\>/
                                syn match   luaFunc /\<bit32\.rrotate\>/
                                syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000001   endif
                            
    1              0.000004   syn match   luaFunc /\<math\.abs\>/
    1              0.000004   syn match   luaFunc /\<math\.acos\>/
    1              0.000004   syn match   luaFunc /\<math\.asin\>/
    1              0.000004   syn match   luaFunc /\<math\.atan\>/
    1              0.000002   if lua_subversion < 3
                                syn match   luaFunc /\<math\.atan2\>/
    1              0.000001   endif
    1              0.000004   syn match   luaFunc /\<math\.ceil\>/
    1              0.000003   syn match   luaFunc /\<math\.sin\>/
    1              0.000003   syn match   luaFunc /\<math\.cos\>/
    1              0.000003   syn match   luaFunc /\<math\.tan\>/
    1              0.000003   syn match   luaFunc /\<math\.deg\>/
    1              0.000003   syn match   luaFunc /\<math\.exp\>/
    1              0.000004   syn match   luaFunc /\<math\.floor\>/
    1              0.000010   syn match   luaFunc /\<math\.log\>/
    1              0.000005   syn match   luaFunc /\<math\.max\>/
    1              0.000003   syn match   luaFunc /\<math\.min\>/
    1              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    1              0.000009   elseif lua_subversion == 1
                                syn match luaFunc /\<math\.log10\>/
    1              0.000001   endif
    1              0.000002   if lua_subversion >= 1
    1              0.000004     syn match luaFunc /\<math\.huge\>/
    1              0.000004     syn match luaFunc /\<math\.fmod\>/
    1              0.000004     syn match luaFunc /\<math\.modf\>/
    1              0.000003     if lua_subversion == 1 || lua_subversion == 2
                                  syn match luaFunc /\<math\.cosh\>/
                                  syn match luaFunc /\<math\.sinh\>/
                                  syn match luaFunc /\<math\.tanh\>/
    1              0.000001     endif
    1              0.000001   endif
    1              0.000004   syn match   luaFunc /\<math\.rad\>/
    1              0.000004   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000002   if lua_subversion < 3
                                syn match   luaFunc /\<math\.pow\>/
                                syn match   luaFunc /\<math\.frexp\>/
                                syn match   luaFunc /\<math\.ldexp\>/
    1              0.000001   else
    1              0.000004     syn match   luaFunc /\<math\.maxinteger\>/
    1              0.000004     syn match   luaFunc /\<math\.mininteger\>/
    1              0.000004     syn match   luaFunc /\<math\.tointeger\>/
    1              0.000004     syn match   luaFunc /\<math\.type\>/
    1              0.000003     syn match   luaFunc /\<math\.ult\>/
    1              0.000001   endif
    1              0.000004   syn match   luaFunc /\<math\.random\>/
    1              0.000004   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000004   syn match   luaFunc /\<math\.pi\>/
                            
    1              0.000003   syn match   luaFunc /\<io\.close\>/
    1              0.000003   syn match   luaFunc /\<io\.flush\>/
    1              0.000003   syn match   luaFunc /\<io\.input\>/
    1              0.000003   syn match   luaFunc /\<io\.lines\>/
    1              0.000004   syn match   luaFunc /\<io\.open\>/
    1              0.000006   syn match   luaFunc /\<io\.output\>/
    1              0.000004   syn match   luaFunc /\<io\.popen\>/
    1              0.000004   syn match   luaFunc /\<io\.read\>/
    1              0.000004   syn match   luaFunc /\<io\.stderr\>/
    1              0.000003   syn match   luaFunc /\<io\.stdin\>/
    1              0.000004   syn match   luaFunc /\<io\.stdout\>/
    1              0.000004   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000004   syn match   luaFunc /\<io\.type\>/
    1              0.000003   syn match   luaFunc /\<io\.write\>/
                            
    1              0.000003   syn match   luaFunc /\<os\.clock\>/
    1              0.000004   syn match   luaFunc /\<os\.date\>/
    1              0.000004   syn match   luaFunc /\<os\.difftime\>/
    1              0.000004   syn match   luaFunc /\<os\.execute\>/
    1              0.000004   syn match   luaFunc /\<os\.exit\>/
    1              0.000004   syn match   luaFunc /\<os\.getenv\>/
    1              0.000004   syn match   luaFunc /\<os\.remove\>/
    1              0.000004   syn match   luaFunc /\<os\.rename\>/
    1              0.000004   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000005   syn match   luaFunc /\<os\.time\>/
    1              0.000003   syn match   luaFunc /\<os\.tmpname\>/
                            
    1              0.000004   syn match   luaFunc /\<debug\.debug\>/
    1              0.000004   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000004   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000004   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000004   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000004   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000004   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000004   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000013   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000002   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
    1              0.000001   endif
    1              0.000002   if lua_subversion >= 1
    1              0.000005     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000014     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000005     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000002     if lua_subversion >= 2
    1              0.000005       syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000004       syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000004       syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000004       syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000001     endif
    1              0.000002     if lua_subversion >= 4
                                  syn match luaFunc /\<debug.setcstacklimit\>/
    1              0.000001     endif
    1              0.000001   endif
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000002 hi def link luaStatement        Statement
    1              0.000002 hi def link luaRepeat           Repeat
    1              0.000002 hi def link luaFor              Repeat
    1              0.000002 hi def link luaString           String
    1              0.000002 hi def link luaString2          String
    1              0.000002 hi def link luaStringDelimiter  luaString
    1              0.000002 hi def link luaNumber           Number
    1              0.000002 hi def link luaOperator         Operator
    1              0.000002 hi def link luaSymbolOperator   luaOperator
    1              0.000002 hi def link luaConstant         Constant
    1              0.000002 hi def link luaCond             Conditional
    1              0.000002 hi def link luaCondElse         Conditional
    1              0.000002 hi def link luaFunction         Function
    1              0.000002 hi def link luaMetaMethod       Function
    1              0.000002 hi def link luaComment          Comment
    1              0.000002 hi def link luaCommentDelimiter luaComment
    1              0.000002 hi def link luaTodo             Todo
    1              0.000002 hi def link luaTable            Structure
    1              0.000002 hi def link luaError            Error
    1              0.000002 hi def link luaParenError       Error
    1              0.000002 hi def link luaSpecial          SpecialChar
    1              0.000002 hi def link luaFunc             Identifier
    1              0.000001 hi def link luaLabel            Label
                            
                            
    1              0.000003 let b:current_syntax = "lua"
                            
    1              0.000009 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  C:\tools\neovim\nvim-win64\share\nvim\runtime\syntax\vim\generated.vim
Sourced 1 time
Total time:   0.001376
 Self time:   0.001376

count  total (s)   self (s)
    1              0.000089 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo argde[dupe] arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bal[t] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cabo[ve] cad[dbuffer] cadde[xpr] caddf[ile] caf[ter] cal[l] cat[ch] cb[uffer] cbe[fore] cbel[ow] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap]
    1              0.000068 syn keyword vimCommand contained  cnorea[bbrev] cnorem[enu] co[py] col[der] colo[rscheme] com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cons[t] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ev[al] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags] hi[ghlight]
    1              0.000069 syn keyword vimCommand contained  hid[e] his[tory] ho[rizontal] i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lab[ove] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] laf[ter] lat[er] lb[uffer] lbe[fore] lbel[ow] lbo[ttom] lc[d] lch[dir] lcl[ose] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow]
    1              0.000077 syn keyword vimCommand contained  ls m[ove] ma[rk] mak[e] map mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] new nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] perlf[ile] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[file] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] pyx pyxd[o] pyt[honx] pyx[file] q[uit] quita[ll] qa[ll] r[ead] rec[over]
    1              0.000069 syn keyword vimCommand contained  red[o] redi[r] redr[aw] redraws[tatus] redrawt[abline] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellra[re] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu] sus[pend] sv[iew] sw[apname] sy[ntax]
    1              0.000067 syn keyword vimCommand contained  synti[me] sync[bind] t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tlm[enu] tln[oremenu] tlu[nmenu] tm[enu] tma[p] tmapc[lear] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] tru[st] try ts[elect] tu[nmenu] tunma[p] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[hada] wu[ndo]
    1              0.000009 syn keyword vimCommand contained  wv[iminfo] x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap] xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
    1              0.000039 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh buflisted bl invbuflisted nobuflisted invbl nobl
    1              0.000117 syn keyword vimOption contained  buftype bt casemap cmp cdhome cdh invcdhome nocdhome invcdh nocdh cdpath cd cedit channel charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw cinscopedecls cinsd clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot completeslash csl confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc cursorline cul invcursorline nocursorline invcul nocul cursorlineopt culopt debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff
    1              0.000048 syn keyword vimOption contained  diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endoffile eof invendoffile noendoffile inveof noeof endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen
    1              0.000041 syn keyword vimOption contained  foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontwide gfw guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic imcmdline imc invimcmdline noimcmdline invimc noimc imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex
    1              0.000041 syn keyword vimOption contained  incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs jumpoptions jop keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispoptions lop lispwords lw list invlist nolist listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl magic invmagic nomagic makeef mef makeencoding menc makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd
    1              0.000036 syn keyword vimOption contained  maxmapdepth mmd maxmempattern mmp menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelineexpr mle invmodelineexpr nomodelineexpr invmle nomle modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mousemoveevent mousemev invmousemoveevent nomousemoveevent invmousemev nomousemev mousescroll mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste pastetoggle pt patchexpr pex patchmode pm
    1              0.000037 syn keyword vimOption contained  path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw pumblend pb pumheight ph pumwidth pw pyxversion pyx quickfixtextfunc qftf quoteescape qe readonly ro invreadonly noreadonly invro noro redrawdebug rdb redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollback scbk scrollbind scb invscrollbind noscrollbind invscb noscb scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shadafile sdf
    1              0.000046 syn keyword vimOption contained  shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showcmdloc sloc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi smarttab sta invsmarttab nosmarttab invsta nosta softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl
    1              0.000042 syn keyword vimOption contained  spellsuggest sps spelloptions spo splitbelow sb invsplitbelow nosplitbelow invsb nosb splitkeep spk splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statuscolumn stc statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tagfunc tfu tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc termpastefilter tpf textwidth tw thesaurus tsr thesaurusfunc tsrfu tildeop top invtildeop notildeop invtop notop
    1              0.000036 syn keyword vimOption contained  timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut varsofttabstop vsts vartabstop vts verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi viminfofile vif virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop winaltkeys wak winbar wbr winblend winbl winhighlight winhl window wi winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh
    1              0.000011 syn keyword vimOption contained  winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    1              0.000002 syn case ignore
                            
    1              0.000045 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre ChanInfo ChanOpen CmdUndefined CmdWinEnter CmdWinLeave CmdlineChanged CmdlineEnter CmdlineLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CompleteDonePre CursorHold CursorHoldI CursorMoved CursorMovedI DiffUpdated DirChanged DirChangedPre EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave
    1              0.000025 syn keyword vimAutoEvent contained  InsertLeavePre MenuPopup ModeChanged OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SearchWrapped SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePost SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabClosed TabEnter TabLeave TabNew TermChanged TermEnter TermLeave TermResponse TextChanged TextChangedI TextChangedP TextChangedT TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinClosed WinEnter WinLeave WinNew WinResized WinScrolled 1 2 3 4
                            
    1              0.000008 syn keyword nvimAutoEvent contained  BufModifiedSet DiagnosticChanged LspAttach LspDetach LspTokenUpdate RecordingEnter RecordingLeave Signal TabNewEntered TermClose TermOpen UIEnter UILeave
                            
    1              0.000001 syn case match
                            
    1              0.000035 syn keyword vimFuncName contained  abs acos add and api_info append appendbufline argc argidx arglistid argv asin assert_beeps assert_equal assert_equalfile assert_exception assert_fails assert_false assert_inrange assert_match assert_nobeep assert_notequal assert_notmatch assert_report assert_true atan atan2 blob2list browse browsedir bufadd bufexists buffer_exists buffer_name buffer_number buflisted bufload bufloaded bufname bufnr bufwinid bufwinnr byte2line byteidx byteidxcomp call ceil chanclose changenr chansend char2nr charclass charcol charidx chdir cindent clearmatches col complete complete_add complete_check complete_info confirm copy cos cosh count ctxget ctxpop ctxpush ctxset ctxsize cursor debugbreak deepcopy delete deletebufline dictwatcheradd dictwatcherdel did_filetype diff_filler diff_hlID digraph_get digraph_getlist digraph_set
    1              0.000035 syn keyword vimFuncName contained  digraph_setlist empty environ escape eval eventhandler executable execute exepath exists exp expand expandcmd extend extendnew feedkeys file_readable filereadable filewritable filter finddir findfile flatten flattennew float2nr floor fmod fnameescape fnamemodify foldclosed foldclosedend foldlevel foldtext foldtextresult foreground fullcommand funcref function garbagecollect get getbufinfo getbufline getbufoneline getbufvar getcellwidths getchangelist getchar getcharmod getcharpos getcharsearch getcharstr getcmdcompltype getcmdline getcmdpos getcmdscreenpos getcmdtype getcmdwintype getcompletion getcurpos getcursorcharpos getcwd getenv getfontname getfperm getfsize getftime getftype getjumplist getline getloclist getmarklist getmatches getmousepos getpid getpos getqflist getreg getreginfo getregtype getscriptinfo
    1              0.000035 syn keyword vimFuncName contained  gettabinfo gettabvar gettabwinvar gettagstack gettext getwininfo getwinpos getwinposx getwinposy getwinvar glob glob2regpat globpath has has_key haslocaldir hasmapto highlightID highlight_exists histadd histdel histget histnr hlID hlexists hostname iconv id indent index indexof input inputdialog inputlist inputrestore inputsave inputsecret insert interrupt invert isdirectory isinf islocked isnan items jobclose jobpid jobresize jobsend jobstart jobstop jobwait join json_decode json_encode keys keytrans last_buffer_nr len libcall libcallnr line line2byte lispindent list2blob list2str localtime log log10 luaeval map maparg mapcheck mapset match matchadd matchaddpos matcharg matchdelete matchend matchfuzzy matchfuzzypos matchlist matchstr matchstrpos max menu_get menu_info min mkdir mode msgpackdump msgpackparse
    1              0.000025 syn keyword vimFuncName contained  nextnonblank nr2char nvim__buf_redraw_range nvim__buf_stats nvim__get_lib_dir nvim__get_runtime nvim__id nvim__id_array nvim__id_dictionary nvim__id_float nvim__inspect_cell nvim__runtime_inspect nvim__screenshot nvim__stats nvim__unpack nvim_buf_add_highlight nvim_buf_attach nvim_buf_clear_highlight nvim_buf_clear_namespace nvim_buf_create_user_command nvim_buf_del_extmark nvim_buf_del_keymap nvim_buf_del_mark nvim_buf_del_user_command nvim_buf_del_var nvim_buf_delete nvim_buf_get_changedtick nvim_buf_get_commands nvim_buf_get_extmark_by_id nvim_buf_get_extmarks nvim_buf_get_keymap nvim_buf_get_lines nvim_buf_get_mark nvim_buf_get_name nvim_buf_get_number nvim_buf_get_offset nvim_buf_get_option nvim_buf_get_text nvim_buf_get_var nvim_buf_is_loaded nvim_buf_is_valid nvim_buf_line_count nvim_buf_set_extmark
    1              0.000041 syn keyword vimFuncName contained  nvim_buf_set_keymap nvim_buf_set_lines nvim_buf_set_mark nvim_buf_set_name nvim_buf_set_option nvim_buf_set_text nvim_buf_set_var nvim_buf_set_virtual_text nvim_call_dict_function nvim_call_function nvim_clear_autocmds nvim_cmd nvim_command nvim_command_output nvim_create_augroup nvim_create_autocmd nvim_create_buf nvim_create_namespace nvim_create_user_command nvim_del_augroup_by_id nvim_del_augroup_by_name nvim_del_autocmd nvim_del_current_line nvim_del_keymap nvim_del_mark nvim_del_user_command nvim_del_var nvim_echo nvim_err_write nvim_err_writeln nvim_eval nvim_eval_statusline nvim_exec nvim_exec2 nvim_exec_autocmds nvim_feedkeys nvim_get_all_options_info nvim_get_autocmds nvim_get_chan_info nvim_get_color_by_name nvim_get_color_map nvim_get_commands nvim_get_context nvim_get_current_buf nvim_get_current_line
    1              0.000024 syn keyword vimFuncName contained  nvim_get_current_tabpage nvim_get_current_win nvim_get_hl nvim_get_hl_by_id nvim_get_hl_by_name nvim_get_hl_id_by_name nvim_get_keymap nvim_get_mark nvim_get_mode nvim_get_namespaces nvim_get_option nvim_get_option_info nvim_get_option_info2 nvim_get_option_value nvim_get_proc nvim_get_proc_children nvim_get_runtime_file nvim_get_var nvim_get_vvar nvim_input nvim_input_mouse nvim_list_bufs nvim_list_chans nvim_list_runtime_paths nvim_list_tabpages nvim_list_uis nvim_list_wins nvim_load_context nvim_notify nvim_open_term nvim_open_win nvim_out_write nvim_parse_cmd nvim_parse_expression nvim_paste nvim_put nvim_replace_termcodes nvim_select_popupmenu_item nvim_set_current_buf nvim_set_current_dir nvim_set_current_line nvim_set_current_tabpage nvim_set_current_win nvim_set_hl nvim_set_hl_ns nvim_set_hl_ns_fast
    1              0.000025 syn keyword vimFuncName contained  nvim_set_keymap nvim_set_option nvim_set_option_value nvim_set_var nvim_set_vvar nvim_strwidth nvim_tabpage_del_var nvim_tabpage_get_number nvim_tabpage_get_var nvim_tabpage_get_win nvim_tabpage_is_valid nvim_tabpage_list_wins nvim_tabpage_set_var nvim_win_close nvim_win_del_var nvim_win_get_buf nvim_win_get_config nvim_win_get_cursor nvim_win_get_height nvim_win_get_number nvim_win_get_option nvim_win_get_position nvim_win_get_tabpage nvim_win_get_var nvim_win_get_width nvim_win_hide nvim_win_is_valid nvim_win_set_buf nvim_win_set_config nvim_win_set_cursor nvim_win_set_height nvim_win_set_hl_ns nvim_win_set_option nvim_win_set_var nvim_win_set_width or pathshorten perleval pow prevnonblank printf prompt_getprompt prompt_setcallback prompt_setinterrupt prompt_setprompt pum_getpos pumvisible py3eval pyeval
    1              0.000035 syn keyword vimFuncName contained  pyxeval rand range readblob readdir readfile reduce reg_executing reg_recorded reg_recording reltime reltimefloat reltimestr remove rename repeat resolve reverse round rpcnotify rpcrequest rpcstart rpcstop rubyeval screenattr screenchar screenchars screencol screenpos screenrow screenstring search searchcount searchdecl searchpair searchpairpos searchpos serverlist serverstart serverstop setbufline setbufvar setcellwidths setcharpos setcharsearch setcmdline setcmdpos setcursorcharpos setenv setfperm setline setloclist setmatches setpos setqflist setreg settabvar settabwinvar settagstack setwinvar sha256 shellescape shiftwidth sign_define sign_getdefined sign_getplaced sign_jump sign_place sign_placelist sign_undefine sign_unplace sign_unplacelist simplify sin sinh sockconnect sort soundfold spellbadword spellsuggest
    1              0.000031 syn keyword vimFuncName contained  split sqrt srand stdioopen stdpath str2float str2list str2nr strcharlen strcharpart strchars strdisplaywidth strftime strgetchar stridx string strlen strpart strptime strridx strtrans strwidth submatch substitute swapinfo swapname synID synIDattr synIDtrans synconcealed synstack system systemlist tabpagebuflist tabpagenr tabpagewinnr tagfiles taglist tan tanh tempname termopen test_garbagecollect_now test_write_list_log timer_info timer_pause timer_start timer_stop timer_stopall tolower toupper tr trim trunc type undofile undotree uniq values virtcol virtcol2col visualmode wait wildmenumode win_execute win_findbuf win_getid win_gettype win_gotoid win_id2tabwin win_id2win win_move_separator win_move_statusline win_screenpos win_splitmove winbufnr wincol windowsversion winheight winlayout winline winnr winrestcmd
    1              0.000006 syn keyword vimFuncName contained  winrestview winsaveview winwidth wordcount writefile xor

FUNCTION  GetRustIndent()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\indent\rust.vim:82
Called 77 times
Total time:   0.032097
 Self time:   0.026958

count  total (s)   self (s)
                            
                            	" Starting assumption: cindent (called at the end) will do it right
                            	" normally. We just want to fix up a few cases.
                            
   77              0.000583 	let line = getline(a:lnum)
                            
   77              0.001072 	if has('syntax_items')
                            		let synname = synIDattr(synID(a:lnum, 1, 1), "name")
                            		if synname == "rustString"
                            			" If the start of the line is in a string, don't change the indent
                            			return -1
                            		elseif synname =~ '\(Comment\|Todo\)' && line !~ '^\s*/\*'  " not /* opening line
                            			if synname =~ "CommentML" " multi-line
                            				if line !~ '^\s*\*' && getline(a:lnum - 1) =~ '^\s*/\*'
                            					" This is (hopefully) the line after a /*, and it has no
                            					" leader, so the correct indentation is that of the
                            					" previous line.
                            					return GetRustIndent(a:lnum - 1)
                            				endif
                            			endif
                            			" If it's in a comment, let cindent take care of it now. This is
                            			" for cases like "/*" where the next line should start " * ", not
                            			" "* " as the code below would otherwise cause for module scope
                            			" Fun fact: "  /*\n*\n*/" takes two calls to get right!
                            			return cindent(a:lnum)
                            		endif
   77              0.000045 	endif
                            
                            	" cindent gets second and subsequent match patterns/struct members wrong,
                            	" as it treats the comma as indicating an unfinished statement::
                            	"
                            	" match a {
                            	"     b => c,
                            	"         d => e,
                            	"         f => g,
                            	" };
                            
                            	" Search backwards for the previous non-empty line.
   77              0.000342 	let prevlinenum = prevnonblank(a:lnum - 1)
   77   0.006328   0.001189 	let prevline = s:get_line_trimmed(prevlinenum)
   77              0.000782 	while prevlinenum > 1 && prevline !~ '[^[:blank:]]'
                            		let prevlinenum = prevnonblank(prevlinenum - 1)
                            		let prevline = s:get_line_trimmed(prevlinenum)
   77              0.000076 	endwhile
                            
                            	" Handle where clauses nicely: subsequent values should line up nicely.
   77              0.000404 	if prevline[len(prevline) - 1] == "," && prevline =~# '^\s*where\s'
                            		return indent(prevlinenum) + 6
   77              0.000048 	endif
                            
   77              0.000718 	if prevline[len(prevline) - 1] == "," && s:get_line_trimmed(a:lnum) !~ '^\s*[\[\]{}]' && prevline !~ '^\s*fn\s' && prevline !~ '([^()]\+,$' && s:get_line_trimmed(a:lnum) !~ '^\s*\S\+\s*=>'
                            		" Oh ho! The previous line ended in a comma! I bet cindent will try to
                            		" take this too far... For now, let's normally use the previous line's
                            		" indent.
                            
                            		" One case where this doesn't work out is where *this* line contains
                            		" square or curly brackets; then we normally *do* want to be indenting
                            		" further.
                            		"
                            		" Another case where we don't want to is one like a function
                            		" definition with arguments spread over multiple lines:
                            		"
                            		" fn foo(baz: Baz,
                            		"        baz: Baz) // <-- cindent gets this right by itself
                            		"
                            		" Another case is similar to the previous, except calling a function
                            		" instead of defining it, or any conditional expression that leaves
                            		" an open paren:
                            		"
                            		" foo(baz,
                            		"     baz);
                            		"
                            		" if baz && (foo ||
                            		"            bar) {
                            		"
                            		" Another case is when the current line is a new match arm.
                            		"
                            		" There are probably other cases where we don't want to do this as
                            		" well. Add them as needed.
                            		return indent(prevlinenum)
   77              0.000048 	endif
                            
   77              0.000795 	if !has("patch-7.4.355")
                            		" cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
                            		"
                            		" static FOO : &'static [bool] = [
                            		" true,
                            		"	 false,
                            		"	 false,
                            		"	 true,
                            		"	 ];
                            		"
                            		"	 uh oh, next statement is indented further!
                            
                            		" Note that this does *not* apply the line continuation pattern properly;
                            		" that's too hard to do correctly for my liking at present, so I'll just
                            		" start with these two main cases (square brackets and not returning to
                            		" column zero)
                            
                            		call cursor(a:lnum, 1)
                            		if searchpair('{\|(', '', '}\|)', 'nbW', 's:is_string_comment(line("."), col("."))') == 0
                            			if searchpair('\[', '', '\]', 'nbW', 's:is_string_comment(line("."), col("."))') == 0
                            				" Global scope, should be zero
                            				return 0
                            			else
                            				" At the module scope, inside square brackets only
                            				"if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
                            				if line =~ "^\\s*]"
                            					" It's the closing line, dedent it
                            					return 0
                            				else
                            					return shiftwidth()
                            				endif
                            			endif
                            		endif
   77              0.000044 	endif
                            
                            	" Fall back on cindent, which does it mostly right
   77              0.014664 	return cindent(a:lnum)

FUNCTION  <SNR>34_get_line_trimmed()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\indent\rust.vim:37
Called 77 times
Total time:   0.005138
 Self time:   0.005138

count  total (s)   self (s)
                            	" Get the line and remove a trailing comment.
                            	" Use syntax highlighting attributes when possible.
                            	" NOTE: this is not accurate; /* */ or a line continuation could trick it
   77              0.000266 	let line = getline(a:lnum)
   77              0.000244 	let line_len = strlen(line)
   77              0.000912 	if has('syntax_items')
                            		" If the last character in the line is a comment, do a binary search for
                            		" the start of the comment.  synID() is slow, a linear search would take
                            		" too long on a long line.
                            		if synIDattr(synID(a:lnum, line_len, 1), "name") =~ 'Comment\|Todo'
                            			let min = 1
                            			let max = line_len
                            			while min < max
                            				let col = (min + max) / 2
                            				if synIDattr(synID(a:lnum, col, 1), "name") =~ 'Comment\|Todo'
                            					let max = col
                            				else
                            					let min = col + 1
                            				endif
                            			endwhile
                            			let line = strpart(line, 0, min - 1)
                            		endif
                            		return substitute(line, "\s*$", "", "")
   77              0.000053 	else
                            		" Sorry, this is not complete, nor fully correct (e.g. string "//").
                            		" Such is life.
   77              0.001379 		return substitute(line, "\s*//.*$", "", "")
                            	endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\ftplugin.vim:14
Called 3086 times
Total time:  23.561588
 Self time:  23.542092

count  total (s)   self (s)
 3086              0.015958     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
 3086              0.002586     endif
                            
 3086              0.015736     let s = expand("<amatch>")
 3086              0.006258     if s != ""
 3086              0.028046       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
 3086              0.002198       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
 6171              0.027202       for name in split(s, '\.')
 3086  11.893853  11.891843         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
 3085  11.462501  11.445015         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
 6170              0.049084       endfor
 3085              0.003368     endif

FUNCTION  provider#clipboard#Call()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\autoload\provider\clipboard.vim:241
Called 36 times
Total time:   0.785951
 Self time:   0.001532

count  total (s)   self (s)
   36              0.000367   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
   36              0.000037   endif
   36              0.000127   let s:here = v:true
   36              0.000039   try
   36   0.784997   0.000578     return call(s:clipboard[a:method],a:args,s:clipboard)
   36              0.000041   finally
   36              0.000094     let s:here = v:false
   36              0.000039   endtry

FUNCTION  <SNR>10_Highlight_Matching_Pair()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime/plugin/matchparen.vim:39
Called 12419 times
Total time:   2.695585
 Self time:   2.528735

count  total (s)   self (s)
                              " Remove any previous match.
12419   0.424248   0.257398   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
12419              0.059648   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
12419              0.007814   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
12419              0.041649   let c_lnum = line('.')
12419              0.035819   let c_col = col('.')
12419              0.019006   let before = 0
                            
12419              0.040078   let text = getline(c_lnum)
12419              0.450592   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
12419              0.029771   if empty(matches)
                                let [c_before, c] = ['', '']
12419              0.010216   else
12419              0.056690     let [c_before, c] = matches[1:2]
12419              0.008943   endif
12419              0.288356   let plist = split(&matchpairs, '.\zs[:,]')
12419              0.040786   let i = index(plist, c)
12419              0.016739   if i < 0
                                " not found, in Insert mode try character before the cursor
10048              0.042147     if c_col > 1 && (mode() == 'i' || mode() == 'R')
 2956              0.008719       let before = strlen(c_before)
 2956              0.004931       let c = c_before
 2956              0.008006       let i = index(plist, c)
10048              0.006710     endif
10048              0.011800     if i < 0
                                  " not found, nothing to do
 9947              0.010111       return
  101              0.000059     endif
 2472              0.001369   endif
                            
                              " Figure out the arguments for searchpairpos().
 2472              0.003783   if i % 2 == 0
  467              0.000817     let s_flags = 'nW'
  467              0.001203     let c2 = plist[i + 1]
 2005              0.001312   else
 2005              0.003474     let s_flags = 'nbW'
 2005              0.003276     let c2 = c
 2005              0.004899     let c = plist[i - 1]
 2472              0.001655   endif
 2472              0.003978   if c == '['
  283              0.000370     let c = '\['
  283              0.000369     let c2 = '\]'
 2472              0.001483   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
 2472              0.003251   if before > 0
  101              0.000387     let has_getcurpos = exists("*getcurpos")
  101              0.000134     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
  101              0.000324       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
  101              0.000062     endif
  101              0.000384     call cursor(c_lnum, c_col - before)
 2472              0.001569   endif
                            
 2472              0.028026   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
 2472              0.001574   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
 2472              0.012346     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
 2472              0.002389     try
 2472              0.055071       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
 2472              0.002275     endtry
 2472              0.001598   endif
                            
                              " Limit the search to lines visible in the window.
 2472              0.008492   let stoplinebottom = line('w$')
 2472              0.006597   let stoplinetop = line('w0')
 2472              0.003620   if i % 2 == 0
  467              0.001269     let stopline = stoplinebottom
 2005              0.001286   else
 2005              0.005320     let stopline = stoplinetop
 2472              0.001617   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
 2472              0.008143   if mode() == 'i' || mode() == 'R'
 1129              0.006373     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
 1343              0.000852   else
 1343              0.007122     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
 2472              0.001700   endif
 2472              0.001854   try
 2472              0.361064     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
 2472              0.002046   endtry
                            
 2472              0.003611   if before > 0
  101              0.000131     if has_getcurpos
  101              0.000340       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
  101              0.000061     endif
 2472              0.001354   endif
                            
                              " If a match is found setup match highlighting.
 2472              0.008625   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
 2193              0.006200     if exists('*matchaddpos')
 2193              0.018570       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
 2193              0.001342     endif
 2193              0.004096     let w:paren_hl_on = 1
 2472              0.001585   endif

FUNCTION  1()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\autoload\provider\clipboard.vim:22
Called 33 times
Total time:   0.000911
 Self time:   0.000911

count  total (s)   self (s)
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
   33              0.000242   if self.owner == a:jobid
   33              0.000129     let self.owner = 0
   33              0.000034   endif
   33              0.000050   if a:data != 0
                                echohl WarningMsg
                                echomsg 'clipboard: error invoking '.get(self.argv, 0, '?').': '.join(self.stderr)
                                echohl None
   33              0.000021   endif

FUNCTION  2()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\autoload\provider\clipboard.vim:164
Called 3 times
Total time:   0.119708
 Self time:   0.000193

count  total (s)   self (s)
    3              0.000014   if type(s:paste[a:reg]) == v:t_func
                                return s:paste[a:reg]()
    3              0.000011   elseif s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
    3              0.000002   end
                            
    3   0.119546   0.000031   let clipboard_data = s:try_cmd(s:paste[a:reg])
    3              0.000102   if match(&clipboard, '\v(unnamed|unnamedplus)') >= 0 && type(clipboard_data) == v:t_list && get(s:selections[a:reg].data, 0, []) ==# clipboard_data
                                " When system clipboard return is same as our cache return the cache
                                " as it contains regtype information
    3              0.000008     return s:selections[a:reg].data
                              end
                              return clipboard_data

FUNCTION  3()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\autoload\provider\clipboard.vim:182
Called 33 times
Total time:   0.664711
 Self time:   0.664711

count  total (s)   self (s)
   33              0.000078   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
   33              0.000020   end
                            
   33              0.000145   if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
   33              0.000020   end
                            
   33              0.000055   if s:cache_enabled == 0
                                call s:try_cmd(s:copy[a:reg], a:lines)
                                "Cache it anyway we can compare it later to get regtype of the yank
                                let s:selections[a:reg] = copy(s:selection)
                                let s:selections[a:reg].data = [a:lines, a:regtype]
                                return 0
   33              0.000020   end
                            
   33              0.000099   if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
   33              0.000019   end
   33              0.000209   let s:selections[a:reg] = copy(s:selection)
   33              0.000094   let selection = s:selections[a:reg]
   33              0.000100   let selection.data = [a:lines, a:regtype]
   33              0.000089   let selection.argv = s:copy[a:reg]
   33              0.000072   let selection.detach = s:cache_enabled
   33              0.000060   let selection.cwd = "/"
   33              0.658883   let jobid = jobstart(selection.argv, selection)
   33              0.000222   if jobid > 0
   33              0.000449     call jobsend(jobid, a:lines)
   33              0.001647     call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
   33              0.000211     if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
   33              0.000037     endif
   33              0.000110     let selection.owner = jobid
   33              0.000057     let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
   33              0.000023   endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
   33              0.000101   if exists('prev_job')
                                call timer_start(1000, {... -> jobwait([prev_job], 0)[0] == -1 && jobstop(prev_job)})
   33              0.000022   endif
                            
   33              0.000065   return ret

FUNCTION  <SNR>2_LoadIndent()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\indent.vim:13
Called 3085 times
Total time:   5.902673
 Self time:   5.902149

count  total (s)   self (s)
 3085              0.013384     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
 3085              0.002186     endif
 3085              0.015896     let s = expand("<amatch>")
 3085              0.006120     if s != ""
 3085              0.007816       if exists("b:did_indent")
                            	unlet b:did_indent
 3085              0.002012       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
 6170              0.025832       for name in split(s, '\.')
 3085   2.951814   2.951289         exe 'runtime! indent/' . name . '.vim'
 3085              2.825837         exe 'runtime! indent/' . name . '.lua'
 6170              0.008727       endfor
 3085              0.002669     endif

FUNCTION  <SNR>31_try()
    Defined: ~/AppData/Local/nvim-data/lazy/indent-blankline.nvim/plugin/indent_blankline.vim:7
Called 15458 times
Total time:   8.746954
 Self time:   8.746954

count  total (s)   self (s)
15458              0.019541     try
15458              8.632013         execute a:cmd
                                catch /E12/
                                    return
15458              0.016504     endtry

FUNCTION  <SNR>15_SynSet()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\syntax\synload.vim:26
Called 3088 times
Total time:  12.986754
 Self time:  12.961352

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
 3088              0.012103   syn clear
 3088              0.009468   if exists("b:current_syntax")
                                unlet b:current_syntax
 3088              0.002254   endif
                            
 3088              0.013479   0verbose let s = expand("<amatch>")
 3088              0.005921   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
 3088              0.005565   elseif s == "OFF"
                                let s = ""
 3088              0.001975   endif
                            
 3088              0.004391   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
 6170              0.027182     for name in split(s, '\.')
 3085              0.007668       if !empty(name)
 3085   6.460650   6.435248         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
 3085              6.346503         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
 3085              0.005958       endif
 6170              0.006060     endfor
 3088              0.002637   endif

FUNCTION  <SNR>16_try_cmd()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime\autoload\provider\clipboard.vim:37
Called 3 times
Total time:   0.119515
 Self time:   0.041632

count  total (s)   self (s)
    3   0.119438   0.041555   let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
    3              0.000019   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
    3              0.000002   endif
    3              0.000005   return out

FUNCTION  <SNR>10_Remove_Matches()
    Defined: C:\tools\neovim\nvim-win64\share\nvim\runtime/plugin/matchparen.vim:197
Called 12607 times
Total time:   0.169086
 Self time:   0.169086

count  total (s)   self (s)
12607              0.076595   if exists('w:paren_hl_on') && w:paren_hl_on
 2194              0.008959     silent! call matchdelete(3)
 2194              0.006385     let w:paren_hl_on = 0
12607              0.011823   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
 3086  23.561588  23.542092  <SNR>1_LoadFTPlugin()
 3088  12.986754  12.961352  <SNR>15_SynSet()
15458   8.746954             <SNR>31_try()
 3085   5.902673   5.902149  <SNR>2_LoadIndent()
12419   2.695585   2.528735  <SNR>10_Highlight_Matching_Pair()
   36   0.785951   0.001532  provider#clipboard#Call()
   33   0.664711             3()
12607   0.169086             <SNR>10_Remove_Matches()
    3   0.119708   0.000193  2()
    3   0.119515   0.041632  <SNR>16_try_cmd()
   77   0.032097   0.026958  GetRustIndent()
   77   0.005138             <SNR>34_get_line_trimmed()
   33   0.000911             1()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 3086  23.561588  23.542092  <SNR>1_LoadFTPlugin()
 3088  12.986754  12.961352  <SNR>15_SynSet()
15458              8.746954  <SNR>31_try()
 3085   5.902673   5.902149  <SNR>2_LoadIndent()
12419   2.695585   2.528735  <SNR>10_Highlight_Matching_Pair()
   33              0.664711  3()
12607              0.169086  <SNR>10_Remove_Matches()
    3   0.119515   0.041632  <SNR>16_try_cmd()
   77   0.032097   0.026958  GetRustIndent()
   77              0.005138  <SNR>34_get_line_trimmed()
   36   0.785951   0.001532  provider#clipboard#Call()
   33              0.000911  1()
    3   0.119708   0.000193  2()

